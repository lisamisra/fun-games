<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Hammer Head - Whack-a-Gnome!</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    touch-action: manipulation;
    font-family: 'Trebuchet MS', system-ui, -apple-system, 'Segoe UI', sans-serif;
    height: 100%;
  }
  *, *::before, *::after {
    cursor: none !important;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Title Screen --- */
  #title-screen {
    position: fixed; inset: 0;
    background: linear-gradient(180deg, #87CEEB 0%, #90EE90 60%, #228B22 100%);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100;
    transition: opacity 0.5s;
  }
  #title-screen.hidden { opacity: 0; pointer-events: none; }
  #title-screen h1 {
    font-size: 4rem; color: #4a2800;
    text-shadow: 3px 3px 0 #FFD700, -1px -1px 0 #2E1500;
    margin-bottom: 0.5rem;
    animation: bounce 1s infinite alternate;
  }
  #title-screen .subtitle {
    font-size: 1.4rem; color: #2E1500; margin-bottom: 1.5rem;
  }
  #difficulty-pick {
    display: flex; flex-wrap: wrap; justify-content: center;
    gap: 1rem; margin-bottom: 1rem;
  }
  .diff-btn {
    font-size: 1.3rem; padding: 0.5em 1.4em;
    background: #fff; color: #4a2800;
    border: 3px solid #8B5A2B; border-radius: 12px;
    font-family: inherit;
    font-weight: bold;
    box-shadow: 0 4px 0 #6B4226;
    transition: transform 0.1s, box-shadow 0.1s, background 0.15s;
  }
  .diff-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #6B4226;
  }
  .diff-btn:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #6B4226;
  }
  .diff-btn.easy { background: #90EE90; border-color: #2E7D32; box-shadow: 0 4px 0 #2E7D32; }
  .diff-btn.easy:hover { box-shadow: 0 6px 0 #2E7D32; }
  .diff-btn.easy:active { box-shadow: 0 2px 0 #2E7D32; }
  .diff-btn.normal { background: #FFD700; border-color: #B8860B; box-shadow: 0 4px 0 #B8860B; }
  .diff-btn.normal:hover { box-shadow: 0 6px 0 #B8860B; }
  .diff-btn.normal:active { box-shadow: 0 2px 0 #B8860B; }
  .diff-btn.hard { background: #FF6347; color: #fff; border-color: #8B0000; box-shadow: 0 4px 0 #8B0000; }
  .diff-btn.hard:hover { box-shadow: 0 6px 0 #8B0000; }
  .diff-btn.hard:active { box-shadow: 0 2px 0 #8B0000; }
  .diff-btn.achal { background: #9B59B6; color: #fff; border-color: #6C3483; box-shadow: 0 4px 0 #6C3483;
    display: inline-flex; align-items: center; gap: 0.4em; }
  .diff-btn.achal:hover { box-shadow: 0 6px 0 #6C3483; }
  .diff-btn.achal:active { box-shadow: 0 2px 0 #6C3483; }
  .diff-btn.achal img {
    width: 1.6em; height: 1.6em;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.6);
    object-fit: cover;
    vertical-align: middle;
  }
  #title-screen .daily-seed {
    font-size: 0.95rem; color: #6B4226; opacity: 0.7; margin-bottom: 1.2rem;
  }
  #title-screen .gnome-preview {
    font-size: 5rem; margin-bottom: 1.5rem;
    animation: wobble 0.8s infinite alternate;
  }
  .big-btn {
    font-size: 1.8rem; padding: 0.7em 2em;
    background: #FF6347; color: white;
    border: 4px solid #8B0000; border-radius: 16px;
    font-family: inherit;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
    box-shadow: 0 6px 0 #8B0000;
    transition: transform 0.1s, box-shadow 0.1s;
  }
  .big-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 0 #8B0000;
  }
  .big-btn:active {
    transform: translateY(3px);
    box-shadow: 0 2px 0 #8B0000;
  }

  /* --- Game Screen --- */
  #game-screen {
    position: fixed; inset: 0;
    background: linear-gradient(180deg, #87CEEB 0%, #7EC850 40%, #5DA832 100%);
    display: none;
  }
  #game-screen.active { display: block; }

  /* --- HUD --- */
  #hud {
    position: absolute; top: 0; left: 0; right: 0;
    display: flex; justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem; z-index: 10;
  }
  #hud-left {
    display: flex; align-items: center; gap: 0.8rem;
  }
  #hud-right {
    display: flex; align-items: center; gap: 0.8rem;
  }
  #score-display {
    font-size: 1.6rem; font-weight: bold;
    color: #fff; background: rgba(0,0,0,0.3);
    padding: 0.4em 1em; border-radius: 12px;
  }
  #timer-display {
    font-size: 1.6rem; font-weight: bold;
    color: #fff; background: rgba(0,0,0,0.3);
    padding: 0.4em 1em; border-radius: 12px;
  }
  #combo-display {
    font-size: 1.4rem; font-weight: bold;
    color: #FFD700; background: rgba(0,0,0,0.3);
    padding: 0.3em 0.8em; border-radius: 12px;
    display: none;
  }
  #combo-display.active { display: block; }
  .score-popup {
    position: fixed;
    font-size: 1.5rem; font-weight: bold;
    color: #FFD700; pointer-events: none;
    animation: score-float 0.8s ease-out forwards;
    z-index: 50;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  }
  .score-popup.penalty { color: #FF4444; }
  @keyframes score-float {
    0%   { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-50px) scale(1.3); opacity: 0; }
  }
  .hud-btn {
    font-size: 1.3rem; padding: 0.3em 0.8em;
    background: rgba(0,0,0,0.3); color: #fff;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 10px; cursor: pointer;
    font-family: inherit; font-weight: bold;
    transition: background 0.15s;
  }
  .hud-btn:hover { background: rgba(0,0,0,0.5); }
  .home-link {
    display: inline-block;
    font-size: 1.2rem; padding: 0.4em 1em;
    background: rgba(255,255,255,0.2); color: #fff;
    border: 2px solid rgba(255,255,255,0.4);
    border-radius: 10px;
    text-decoration: none; font-weight: bold;
    font-family: inherit;
    transition: background 0.15s;
  }
  .home-link:hover { background: rgba(255,255,255,0.35); }
  #title-screen .home-link {
    margin-top: 1.5rem;
    background: rgba(0,0,0,0.15); color: #2E1500;
    border-color: rgba(0,0,0,0.2);
  }
  #title-screen .home-link:hover { background: rgba(0,0,0,0.25); }
  #health-container {
    display: flex; align-items: center; gap: 0.6rem;
    background: rgba(0,0,0,0.3); padding: 0.4em 1em;
    border-radius: 12px;
  }
  #health-label {
    font-size: 1.2rem; color: #fff; font-weight: bold;
  }
  #health-bar-bg {
    width: 200px; height: 22px;
    background: #555; border-radius: 11px;
    overflow: hidden; border: 2px solid #333;
  }
  #health-bar {
    width: 100%; height: 100%;
    background: linear-gradient(90deg, #FF4444, #FF6666);
    border-radius: 11px;
    transition: width 0.3s ease;
  }
  #health-text {
    font-size: 1rem; color: #fff; min-width: 3em; text-align: right;
  }

  /* --- Field --- */
  #field {
    position: absolute;
    inset: 0;
  }

  /* --- Hole --- */
  .hole {
    position: absolute;
  }
  .hole-mound {
    position: absolute; bottom: 0;
    width: 100%; height: 50%;
    background: radial-gradient(ellipse at 50% 80%, #6B4226 0%, #8B5A2B 40%, #5C3317 100%);
    border-radius: 50%; z-index: 3;
    box-shadow: inset 0 -8px 15px rgba(0,0,0,0.3);
  }
  .hole-dark {
    position: absolute; bottom: 10%;
    left: 12.5%; width: 75%; height: 35%;
    background: radial-gradient(ellipse, #1a0a00 0%, #2d1500 100%);
    border-radius: 50%; z-index: 1;
  }
  .hole-clip {
    position: absolute; bottom: 15%;
    left: 0; right: 0; height: 85%;
    overflow: hidden; z-index: 4;
  }
  .gnome-container {
    position: absolute; bottom: 0;
    left: 50%;
    transform: translateX(-50%) translateY(100%);
    text-align: center;
    transition: transform 0.15s ease-out;
    pointer-events: none;
  }
  .gnome-container.visible {
    transform: translateX(-50%) translateY(10%);
    pointer-events: auto;
  }
  .gnome-container.hit {
    animation: gnome-hit 0.3s ease-out forwards;
  }
  .gnome {
    font-size: 3.2rem;
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
    transition: filter 0.15s;
  }
  .gnome-container.hit .gnome {
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3)) brightness(1.5);
  }
  /* --- Charge indicator (wind-up hold) --- */
  .gnome-container.charging .gnome {
    animation: charge-pulse 0.15s ease-in-out infinite alternate;
  }
  .gnome-container.charging::before {
    content: '';
    position: absolute;
    bottom: 0; left: 50%;
    width: 0; height: 0;
    transform: translateX(-50%);
    border-radius: 50%;
    border: 3px solid rgba(255, 100, 50, 0.8);
    box-shadow: 0 0 8px rgba(255, 100, 50, 0.5);
    animation: charge-ring var(--charge-duration, 0.3s) ease-out forwards;
    pointer-events: none;
    z-index: 10;
  }
  @keyframes charge-pulse {
    from { transform: scale(1); }
    to   { transform: scale(1.12); }
  }
  @keyframes charge-ring {
    0%   { width: 0; height: 0; opacity: 0.4; }
    100% { width: 120%; height: 120%; opacity: 1; }
  }

  .gnome-container.golden .gnome {
    filter: drop-shadow(0 0 12px rgba(255,215,0,0.8)) drop-shadow(0 4px 6px rgba(0,0,0,0.3));
    animation: golden-glow 0.5s infinite alternate;
  }
  /* Override golden glow during charge */
  .gnome-container.golden.charging .gnome {
    animation: charge-pulse 0.15s ease-in-out infinite alternate;
    filter: drop-shadow(0 0 12px rgba(255,215,0,0.8)) drop-shadow(0 4px 6px rgba(0,0,0,0.3));
  }
  @keyframes golden-glow {
    from { filter: drop-shadow(0 0 8px rgba(255,215,0,0.6)) drop-shadow(0 4px 6px rgba(0,0,0,0.3)); }
    to   { filter: drop-shadow(0 0 18px rgba(255,215,0,1)) drop-shadow(0 4px 6px rgba(0,0,0,0.3)) brightness(1.15); }
  }

  /* --- Speech Bubble --- */
  .speech-bubble {
    position: absolute; top: -10px; left: 50%;
    transform: translateX(-50%) scale(0);
    background: #fff; color: #333;
    font-size: 1.1rem; font-weight: bold;
    padding: 0.3em 0.7em; border-radius: 12px;
    border: 2px solid #999;
    white-space: nowrap;
    opacity: 0; z-index: 20;
    transition: transform 0.15s ease-out, opacity 0.15s;
    pointer-events: none;
  }
  .speech-bubble::after {
    content: '';
    position: absolute; bottom: -8px; left: 50%;
    transform: translateX(-50%);
    width: 0; height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid #fff;
  }
  .speech-bubble.show {
    transform: translateX(-50%) scale(1);
    opacity: 1;
  }

  /* --- Miss bubble (appears at click location) --- */
  .miss-bubble {
    position: fixed;
    font-size: 1.4rem; font-weight: bold;
    color: #FF6347; pointer-events: none;
    animation: float-up 1s ease-out forwards;
    z-index: 50;
    text-shadow: 1px 1px 0 #fff;
  }

  /* --- Hammer --- */
  #hammer {
    position: fixed; z-index: 200;
    font-size: 2.8rem;
    pointer-events: none;
    transform: translate(-30%, -30%) rotate(-15deg);
    transition: transform 0.08s ease-out;
    filter: drop-shadow(2px 4px 4px rgba(0,0,0,0.4));
  }
  #hammer.smash {
    transform: translate(-30%, -30%) rotate(30deg) scale(1.15);
  }
  #hammer.hidden { display: none; }

  /* --- Tap flash (touch devices) --- */
  .tap-hammer {
    position: fixed; z-index: 199;
    font-size: 2.8rem;
    pointer-events: none;
    animation: tap-smash 0.25s ease-out forwards;
    filter: drop-shadow(2px 4px 4px rgba(0,0,0,0.4));
  }
  @keyframes tap-smash {
    0%   { transform: translate(-30%, -30%) rotate(-15deg) scale(1); opacity: 1; }
    40%  { transform: translate(-30%, -30%) rotate(30deg) scale(1.2); opacity: 1; }
    100% { transform: translate(-30%, -30%) rotate(30deg) scale(0.9); opacity: 0; }
  }

  /* --- Hit Stars --- */
  .star {
    position: fixed; pointer-events: none;
    font-size: 1.5rem; z-index: 150;
  }

  /* --- Game Over Screen --- */
  #game-over {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.75);
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 300;
  }
  #game-over.active { display: flex; }
  #game-over h2 {
    font-size: 3.5rem; color: #FFD700;
    text-shadow: 2px 2px 4px #000;
    margin-bottom: 0.5rem;
    animation: bounce 0.8s infinite alternate;
  }
  #game-over .final-score {
    font-size: 2rem; color: #fff; margin-bottom: 0.3rem;
  }
  #game-over .final-difficulty {
    font-size: 1.3rem; color: #FFD700; margin-bottom: 0.3rem;
    font-weight: bold;
  }
  #game-over .final-time {
    font-size: 1.6rem; color: #fff; margin-bottom: 0.3rem;
  }
  #game-over .final-detail {
    font-size: 1.2rem; color: #ccc; margin-bottom: 0.3rem;
  }
  #game-over .final-seed {
    font-size: 0.9rem; color: #888; margin-bottom: 1.5rem;
  }
  .green-btn {
    font-size: 1.5rem; padding: 0.6em 1.8em;
    background: #4CAF50; color: white;
    border: 4px solid #2E7D32; border-radius: 14px;
    font-family: inherit;
    box-shadow: 0 5px 0 #2E7D32;
    transition: transform 0.1s, box-shadow 0.1s;
  }
  .green-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 7px 0 #2E7D32;
  }
  .green-btn:active {
    transform: translateY(3px);
    box-shadow: 0 2px 0 #2E7D32;
  }

  /* --- Screen shake --- */
  #game-screen.shake {
    animation: shake 0.3s ease-out;
  }

  /* --- Animations --- */
  @keyframes bounce {
    from { transform: translateY(0); }
    to   { transform: translateY(-12px); }
  }
  @keyframes wobble {
    from { transform: rotate(-8deg); }
    to   { transform: rotate(8deg); }
  }
  @keyframes gnome-hit {
    0%   { transform: translateX(-50%) translateY(10%) scale(1); }
    30%  { transform: translateX(-50%) translateY(-20%) scale(1.1); }
    100% { transform: translateX(-50%) translateY(100%) scale(0.8); }
  }
  @keyframes float-up {
    0%   { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-60px) scale(1.4); opacity: 0; }
  }
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20%  { transform: translateX(-8px) rotate(-1deg); }
    40%  { transform: translateX(8px) rotate(1deg); }
    60%  { transform: translateX(-5px); }
    80%  { transform: translateX(5px); }
  }

  /* --- Responsive: small screens --- */
  @media (max-width: 600px) {
    #title-screen h1 { font-size: 2.5rem; }
    #title-screen .subtitle { font-size: 1.1rem; }
    #title-screen .gnome-preview { font-size: 3.5rem; }
    .diff-btn { font-size: 1.1rem; padding: 0.4em 1em; }
    #hud { padding: 0.6rem 0.8rem; }
    #hud-left, #hud-right { gap: 0.4rem; }
    #score-display, #timer-display { font-size: 1.1rem; padding: 0.3em 0.6em; }
    #combo-display { font-size: 1rem; padding: 0.2em 0.5em; }
    .hud-btn { font-size: 1.1rem; padding: 0.25em 0.6em; }
    #health-label { display: none; }
    #health-bar-bg { width: 100px; height: 18px; }
    #health-text { font-size: 0.85rem; }
    #health-container { padding: 0.3em 0.6em; }
    #game-over h2 { font-size: 2.2rem; }
    #game-over .final-score { font-size: 1.4rem; }
    #game-over .final-detail { font-size: 1rem; }
    .green-btn { font-size: 1.2rem; padding: 0.5em 1.4em; }
  }

  /* --- iOS safe area padding --- */
  @supports (padding-top: env(safe-area-inset-top)) {
    #hud { padding-top: calc(0.6rem + env(safe-area-inset-top)); }
  }
</style>
</head>
<body>

<!-- Title Screen -->
<div id="title-screen">
  <div class="gnome-preview">üßô‚Äç‚ôÇÔ∏è</div>
  <h1>Hammer Head</h1>
  <p class="subtitle">Whack that gnome!</p>
  <p class="daily-seed" id="daily-seed"></p>
  <div id="difficulty-pick">
    <button class="diff-btn easy" onclick="startGame('easy')">Easy</button>
    <button class="diff-btn normal" onclick="startGame('normal')">Normal</button>
    <button class="diff-btn hard" onclick="startGame('hard')">Hard</button>
    <button class="diff-btn achal" onclick="startGame('achal')"><img src="achal-anna.png" alt="">Achal Anna</button>
  </div>
  <a href="index.html" class="home-link">Back to Games</a>
</div>

<!-- Game Screen -->
<div id="game-screen">
  <div id="hud">
    <div id="hud-left">
      <button class="hud-btn" id="quit-btn" onclick="quitGame()">Quit</button>
      <button class="hud-btn" id="mute-btn" onclick="toggleMute()">üîä</button>
      <div id="score-display">Score: 0</div>
      <div id="timer-display">0:00</div>
      <div id="combo-display">x2</div>
    </div>
    <div id="hud-right">
      <div id="health-container">
        <span id="health-label">Gnome HP:</span>
        <div id="health-bar-bg"><div id="health-bar"></div></div>
        <span id="health-text">10/10</span>
      </div>
    </div>
  </div>
  <div id="field"></div>
</div>

<!-- Hammer (follows mouse) -->
<div id="hammer">üî®</div>

<!-- Game Over Screen -->
<div id="game-over">
  <h2>You got him!</h2>
  <div class="final-difficulty" id="final-difficulty"></div>
  <div class="final-time" id="final-time"></div>
  <div class="final-score" id="final-score">Score: 0</div>
  <div class="final-detail" id="final-bonus"></div>
  <div class="final-detail" id="final-detail"></div>
  <div class="final-seed" id="final-seed"></div>
  <button class="green-btn" onclick="restartGame()">Play Again!</button>
  <a href="index.html" class="home-link" style="margin-top: 1rem;">Back to Games</a>
</div>

<script>
// --- Game State ---
const MAX_HP = 10;

// --- Seeded RNG (daily seed ‚Äî same day + difficulty = same patterns) ---
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
function dateSeed(dateStr, difficulty) {
  let h = 0;
  const s = dateStr + ':' + difficulty;
  for (let i = 0; i < s.length; i++) {
    h = Math.imul(31, h) + s.charCodeAt(i) | 0;
  }
  return h;
}
function getTodayStr() {
  const d = new Date();
  return d.getUTCFullYear() + '-' +
    String(d.getUTCMonth() + 1).padStart(2, '0') + '-' +
    String(d.getUTCDate()).padStart(2, '0');
}
let rng = null;
const todayStr = getTodayStr();

// Show today's seed on title screen
document.getElementById('daily-seed').textContent = 'Daily Seed: ' + todayStr;

// --- Difficulty presets ---
const DIFFICULTY = {
  easy:   { visibleMin: 1800, visibleRange: 700, gapMin: 1000, gapRange: 1200, missHeal: 0,
            missPenalty: 25, grass: ['#87CEEB', '#7EC850', '#5DA832'], label: 'Easy' },
  normal: { visibleMin: 1300, visibleRange: 500, gapMin: 800,  gapRange: 1000, missHeal: 2,
            missPenalty: 50, grass: ['#87CEEB', '#C8B850', '#8B7D28'], label: 'Normal' },
  hard:   { visibleMin: 850,  visibleRange: 300, gapMin: 400,  gapRange: 600,  missHeal: MAX_HP,
            missPenalty: 75, grass: ['#8B9EAB', '#A85A50', '#6B3028'], label: 'Hard', gnomesPerRound: 1 },
  achal:  { visibleMin: 1500, visibleRange: 500, gapMin: 600,  gapRange: 800,  missHeal: MAX_HP,
            missPenalty: 100, grass: ['#FF69B4', '#9B59B6', '#6C3483'], label: 'Achal Anna', gnomesPerRound: 2 },
};
let currentDifficulty = DIFFICULTY.normal;

// Responsive hole sizing
function getHoleParams() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const small = w < 500 || h < 700;
  return {
    count: small ? 6 : 9,
    width: small ? 120 : 160,
    height: small ? 100 : 130,
    minDist: small ? 130 : 170,
  };
}

let score = 0;
let hits = 0;
let misses = 0;
let combo = 0;
let gnomeHP = MAX_HP;
let activeHoles = [];
let roundHitsCount = 0;
let gnomeVisible = false;
let gnomeAppearedAt = 0;
let gnomeTimeout = null;
let popInterval = null;
let relocateTimeout = null;
let gameRunning = false;
let gameStartTime = 0;
let elapsedTime = 0;
let timerInterval = null;
let muted = localStorage.getItem('hammerhead-muted') === 'true';

// --- Charge (wind-up hold) state ---
let chargeTarget = null;        // gnome-container element being charged
let chargeStartTime = 0;        // Date.now() when charge began
let chargeIsTouch = false;      // was this charge initiated by touch?
const CHARGE_MS_TOUCH = 300;    // touch charge duration
const CHARGE_MS_MOUSE = 100;    // mouse charge duration (cursor travel is the real cost)

// --- DOM refs ---
const hammer = document.getElementById('hammer');
const field = document.getElementById('field');
const gameScreen = document.getElementById('game-screen');
const titleScreen = document.getElementById('title-screen');
const gameOver = document.getElementById('game-over');
const scoreDisplay = document.getElementById('score-display');
const healthBar = document.getElementById('health-bar');
const healthText = document.getElementById('health-text');
const muteBtn = document.getElementById('mute-btn');
const timerDisplay = document.getElementById('timer-display');
const comboDisplay = document.getElementById('combo-display');

// --- Mute ---
function updateMuteBtn() {
  muteBtn.textContent = muted ? 'üîá' : 'üîä';
}
function toggleMute() {
  muted = !muted;
  localStorage.setItem('hammerhead-muted', muted);
  updateMuteBtn();
  if (muted) { stopMusic(); }
  else if (gameRunning) { startMusic(); }
}
updateMuteBtn();

// --- Generate random non-overlapping hole positions ---
function generateHolePositions(params) {
  const padding = params.width < 140 ? 40 : 80;
  const topPadding = params.width < 140 ? 70 : 100;
  const maxW = window.innerWidth - params.width - padding;
  const maxH = window.innerHeight - params.height - padding;
  const positions = [];
  let attempts = 0;

  while (positions.length < params.count && attempts < 2000) {
    attempts++;
    const rand = rng || Math.random;
    const x = padding + rand() * (maxW - padding);
    const y = topPadding + rand() * (maxH - topPadding);

    let tooClose = false;
    for (const p of positions) {
      const dx = p.x - x;
      const dy = p.y - y;
      if (Math.sqrt(dx * dx + dy * dy) < params.minDist) {
        tooClose = true;
        break;
      }
    }
    if (!tooClose) positions.push({ x, y });
  }
  return positions;
}

// --- Build holes ---
let holes = [];
function buildField() {
  field.innerHTML = '';
  holes = [];
  const params = getHoleParams();
  const positions = generateHolePositions(params);

  for (let i = 0; i < positions.length; i++) {
    const hole = document.createElement('div');
    hole.className = 'hole';
    hole.style.left = positions[i].x + 'px';
    hole.style.top = positions[i].y + 'px';
    hole.style.width = params.width + 'px';
    hole.style.height = params.height + 'px';
    hole.innerHTML = `
      <div class="speech-bubble"></div>
      <div class="hole-clip">
        <div class="gnome-container" data-index="${i}">
          <div class="gnome">üßô‚Äç‚ôÇÔ∏è</div>
        </div>
      </div>
      <div class="hole-dark"></div>
      <div class="hole-mound"></div>
    `;
    field.appendChild(hole);
    holes.push(hole);
  }
}

// --- Input handling (mouse + touch) ---
const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let tapHammerTimeout = null;

// Hide persistent hammer on touch-only devices
if (hasTouch && !window.matchMedia('(pointer: fine)').matches) {
  hammer.classList.add('hidden');
}

// Mouse: hammer follows cursor + cancel charge if moved off gnome
document.addEventListener('mousemove', (e) => {
  if (!hammer.classList.contains('hidden')) {
    hammer.style.left = e.clientX + 'px';
    hammer.style.top = e.clientY + 'px';
  }
  // Cancel charge if mouse moves off the charged gnome
  if (chargeTarget) {
    const el = document.elementFromPoint(e.clientX, e.clientY);
    if (!el || !el.closest('.gnome-container') || el.closest('.gnome-container') !== chargeTarget) {
      cancelCharge();
    }
  }
});

document.addEventListener('mousedown', (e) => {
  if (!hammer.classList.contains('hidden')) {
    hammer.classList.add('smash');
  }
  if (gameRunning) handlePress(e.clientX, e.clientY, e.target, false);
});

document.addEventListener('mouseup', (e) => {
  hammer.classList.remove('smash');
  if (gameRunning) handleRelease(e.clientX, e.clientY);
});

// Touch: show tap-flash hammer at touch point
document.addEventListener('touchstart', (e) => {
  const touch = e.touches[0];
  const target = document.elementFromPoint(touch.clientX, touch.clientY);

  // Prevent scroll/zoom on game field, but allow buttons to work
  if (gameRunning && target && !target.closest('#hud')) {
    e.preventDefault();
  }

  // Show a brief hammer animation at tap point
  showTapFlash(touch.clientX, touch.clientY);

  if (gameRunning) handlePress(touch.clientX, touch.clientY, target, true);
}, { passive: false });

document.addEventListener('touchend', (e) => {
  if (!gameRunning) return;
  // Use changedTouches for the released finger
  const touch = e.changedTouches[0];
  handleRelease(touch.clientX, touch.clientY);
}, { passive: false });

// Prevent unwanted gestures on the game field; cancel charge if finger moves off gnome
document.addEventListener('touchmove', (e) => {
  if (gameRunning) e.preventDefault();
  if (chargeTarget) {
    const touch = e.touches[0];
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!el || !el.closest('.gnome-container') || el.closest('.gnome-container') !== chargeTarget) {
      cancelCharge();
    }
  }
}, { passive: false });

function showTapFlash(x, y) {
  const h = document.createElement('div');
  h.className = 'tap-hammer';
  h.textContent = 'üî®';
  h.style.left = x + 'px';
  h.style.top = y + 'px';
  document.body.appendChild(h);
  setTimeout(() => h.remove(), 300);
}

// --- Web Audio API sound effects ---
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  // iOS: resume suspended context
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}
// Unlock AudioContext on first user gesture (iOS requirement)
function unlockAudio() {
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Create and immediately stop a silent buffer to fully unlock
  const buf = ctx.createBuffer(1, 1, 22050);
  const src = ctx.createBufferSource();
  src.buffer = buf;
  src.connect(ctx.destination);
  src.start(0);
}
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('click', unlockAudio, { once: true });

// "pfffft" - filtered noise burst (raspberry sound)
function playPfffft() {
  const ctx = getAudioCtx();
  const duration = 0.3;
  const bufSize = ctx.sampleRate * duration;
  const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  const data = buf.getChannelData(0);
  // Shaped noise
  for (let i = 0; i < bufSize; i++) {
    const t = i / bufSize;
    const envelope = (1 - t) * Math.pow(1 - t, 2);
    data[i] = (Math.random() * 2 - 1) * envelope * 0.4;
  }
  const src = ctx.createBufferSource();
  src.buffer = buf;
  // Bandpass filter for "raspberry" character
  const filter = ctx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 300;
  filter.Q.value = 2;
  const gain = ctx.createGain();
  gain.gain.value = 0.6;
  src.connect(filter);
  filter.connect(gain);
  gain.connect(ctx.destination);
  src.start();
}

// "ouuuuch" - descending tone with vibrato
function playOuch() {
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(600, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(150, ctx.currentTime + 0.4);
  gain.gain.setValueAtTime(0.3, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.5);
}

// "lol" - two quick ascending playful notes
function playLol() {
  const ctx = getAudioCtx();
  const notes = [400, 600, 800];
  notes.forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.value = freq;
    const start = ctx.currentTime + i * 0.1;
    gain.gain.setValueAtTime(0, start);
    gain.gain.linearRampToValueAtTime(0.15, start + 0.02);
    gain.gain.linearRampToValueAtTime(0, start + 0.1);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(start);
    osc.stop(start + 0.12);
  });
}

// "oh no" - sad descending two-note
function playOhNo() {
  const ctx = getAudioCtx();
  const notes = [500, 300];
  notes.forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    const start = ctx.currentTime + i * 0.25;
    gain.gain.setValueAtTime(0.3, start);
    gain.gain.exponentialRampToValueAtTime(0.01, start + 0.3);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(start);
    osc.stop(start + 0.35);
  });
}

// --- Background Music (procedural chiptune) ---
let musicPlaying = false;
let musicInterval = null;
let musicGain = null;

function startMusic() {
  if (musicPlaying || muted) return;
  const ctx = getAudioCtx();
  musicPlaying = true;

  // Master gain for music (lower than SFX)
  musicGain = ctx.createGain();
  musicGain.gain.value = 0.12;
  musicGain.connect(ctx.destination);

  const BPM = 150;
  const sixteenth = 60 / BPM / 4;
  let nextTime = ctx.currentTime + 0.05;
  let step = 0;

  // Energetic pentatonic melody (16th note pattern, 32 steps = 2 bars)
  const melody = [
    523, 0, 659, 0, 784, 0, 659, 523,
    587, 0, 784, 0, 880, 784, 659, 0,
    523, 0, 659, 784, 880, 0, 1047, 880,
    784, 0, 659, 0, 523, 440, 523, 0,
  ];

  // Driving bass (8th notes, 16 steps = 2 bars)
  const bass = [
    131, 131, 131, 196, 147, 147, 147, 196,
    165, 165, 165, 220, 196, 196, 131, 131,
  ];

  function playNote(freq, time, dur, type, dest) {
    if (!freq) return;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0.5, time);
    g.gain.exponentialRampToValueAtTime(0.01, time + dur);
    osc.connect(g);
    g.connect(dest);
    osc.start(time);
    osc.stop(time + dur + 0.01);
  }

  function playKick(time) {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, time);
    osc.frequency.exponentialRampToValueAtTime(30, time + 0.15);
    g.gain.setValueAtTime(0.7, time);
    g.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
    osc.connect(g);
    g.connect(musicGain);
    osc.start(time);
    osc.stop(time + 0.21);
  }

  function playHat(time, loud) {
    const bufSize = Math.floor(ctx.sampleRate * 0.04);
    const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufSize);
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 9000;
    const g = ctx.createGain();
    g.gain.value = loud ? 0.5 : 0.25;
    src.connect(hp);
    hp.connect(g);
    g.connect(musicGain);
    src.start(time);
  }

  function scheduler() {
    if (!musicPlaying) return;
    while (nextTime < ctx.currentTime + 0.25) {
      const mIdx = step % melody.length;
      const bIdx = Math.floor(step / 2) % bass.length;

      // Melody
      playNote(melody[mIdx], nextTime, sixteenth * 1.5, 'square', musicGain);

      // Bass (every 8th note)
      if (step % 2 === 0) {
        playNote(bass[bIdx], nextTime, sixteenth * 3, 'sawtooth', musicGain);
      }

      // Kick on beats 1 and 3
      if (step % 8 === 0 || step % 8 === 4) {
        playKick(nextTime);
      }

      // Hi-hat on every 8th, accent on offbeats
      if (step % 2 === 0) {
        playHat(nextTime, step % 4 === 2);
      }

      step++;
      nextTime += sixteenth;
    }
  }

  scheduler();
  musicInterval = setInterval(scheduler, 100);
}

function stopMusic() {
  musicPlaying = false;
  if (musicInterval) { clearInterval(musicInterval); musicInterval = null; }
  if (musicGain) {
    try { musicGain.gain.exponentialRampToValueAtTime(0.001, getAudioCtx().currentTime + 0.3); } catch(e) {}
    musicGain = null;
  }
}

// Golden gnome sparkle sound
function playSparkle() {
  const ctx = getAudioCtx();
  const notes = [1047, 1319, 1568, 2093];
  notes.forEach((freq, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const start = ctx.currentTime + i * 0.08;
    gain.gain.setValueAtTime(0.15, start);
    gain.gain.exponentialRampToValueAtTime(0.01, start + 0.15);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(start);
    osc.stop(start + 0.18);
  });
}

// Unified speak() replacement - maps text to sound effects
function speak(text) {
  if (muted) return;
  switch (text) {
    case 'pfffft': playPfffft(); break;
    case 'ouuuuch': playOuch(); break;
    case 'lol': playLol(); break;
    case 'oh no!': playOhNo(); break;
    case 'sparkle': playSparkle(); break;
  }
}

// --- Show speech bubble ---
function showBubble(holeIndex, text, duration = 800) {
  const bubble = holes[holeIndex].querySelector('.speech-bubble');
  bubble.textContent = text;
  bubble.classList.add('show');
  setTimeout(() => bubble.classList.remove('show'), duration);
}

// --- Golden gnome state ---
let goldenActive = false; // is the current round a golden gnome?

// --- Spawn gnome(s) at random hole(s) ---
function spawnGnome() {
  if (!gameRunning) return;

  const count = currentDifficulty.gnomesPerRound || 1;
  activeHoles = [];
  roundHitsCount = 0;
  gnomeVisible = true;
  gnomeAppearedAt = Date.now();

  // Hard/Achal: 12% chance to spawn a golden gnome (single, replaces normal round)
  const forceGolden = new URLSearchParams(window.location.search).get('golden') === 'true';
  const isHardPlus = currentDifficulty === DIFFICULTY.hard || currentDifficulty === DIFFICULTY.achal;
  goldenActive = forceGolden || (isHardPlus && rng() < 0.12);

  // Pick N different random holes (golden = always 1)
  const spawnCount = goldenActive ? 1 : count;
  const available = [];
  for (let i = 0; i < holes.length; i++) available.push(i);
  for (let i = 0; i < spawnCount && available.length > 0; i++) {
    const pick = Math.floor(rng() * available.length);
    const holeIdx = available.splice(pick, 1)[0];
    activeHoles.push(holeIdx);

    const container = holes[holeIdx].querySelector('.gnome-container');
    container.classList.remove('hit', 'golden');
    if (goldenActive) container.classList.add('golden');
    container.classList.add('visible');
    showBubble(holeIdx, goldenActive ? '‚ú®' : 'pfffft!');
  }
  speak(goldenActive ? 'sparkle' : 'pfffft');

  // Auto-hide after a window (gnomes escape)
  // In Achal Anna mode, visible time shrinks as gnome HP drops
  const hpRatio = gnomeHP / MAX_HP;
  const hpScale = (currentDifficulty.gnomesPerRound || 1) > 1 ? (0.4 + 0.6 * hpRatio) : 1;
  const visibleTime = (currentDifficulty.visibleMin + rng() * currentDifficulty.visibleRange) * hpScale;
  gnomeTimeout = setTimeout(() => {
    if (gnomeVisible && gameRunning) {
      gnomeEscaped();
    }
  }, visibleTime);

  // Schedule next round
  const nextDelay = currentDifficulty.gapMin + rng() * currentDifficulty.gapRange;
  popInterval = setTimeout(spawnGnome, visibleTime + nextDelay);

  // Achal Anna mode: below 4 HP, one gnome randomly relocates mid-round
  if ((currentDifficulty.gnomesPerRound || 1) > 1 && gnomeHP < 4) {
    const relocateDelay = visibleTime * 0.5;
    relocateTimeout = setTimeout(() => {
      if (!gnomeVisible || !gameRunning) return;

      // Find gnomes still visible
      const stillVisible = activeHoles.filter(idx =>
        holes[idx].querySelector('.gnome-container').classList.contains('visible')
      );
      if (stillVisible.length === 0) return;

      // Pick one to relocate
      const victim = stillVisible[Math.floor(rng() * stillVisible.length)];
      const victimContainer = holes[victim].querySelector('.gnome-container');
      // Cancel charge if this gnome was being charged
      if (chargeTarget === victimContainer) cancelCharge();
      victimContainer.classList.remove('visible');

      // Pick a new hole not currently active
      const freeHoles = [];
      for (let i = 0; i < holes.length; i++) {
        if (!activeHoles.includes(i)) freeHoles.push(i);
      }
      if (freeHoles.length === 0) return;

      const newIdx = freeHoles[Math.floor(rng() * freeHoles.length)];
      activeHoles[activeHoles.indexOf(victim)] = newIdx;

      const newContainer = holes[newIdx].querySelector('.gnome-container');
      newContainer.classList.remove('hit');
      newContainer.classList.add('visible');
      showBubble(newIdx, 'üòà', 600);
      speak('lol');

      // Give half the original visible time after relocation
      clearTimeout(gnomeTimeout);
      const halfTime = visibleTime / 2;
      gnomeTimeout = setTimeout(() => {
        if (gnomeVisible && gameRunning) gnomeEscaped();
      }, halfTime);

      clearTimeout(popInterval);
      popInterval = setTimeout(spawnGnome, halfTime + nextDelay);
    }, relocateDelay);
  }
}

// --- Gnome(s) escape (player was too slow) ---
function gnomeEscaped() {
  // Golden gnome escaping = good! No penalty.
  if (goldenActive) {
    hideAllGnomes();
    return;
  }
  // Show laugh on all remaining visible gnomes
  for (const idx of activeHoles) {
    const container = holes[idx].querySelector('.gnome-container');
    if (container.classList.contains('visible')) {
      showBubble(idx, 'lol üòÇ', 900);
    }
  }
  hideAllGnomes();
  misses++;
  combo = 0;
  updateCombo();
  applyMissPenalty();
  healGnomeOnMiss();
  setTimeout(() => speak('lol'), 150);
}

// --- Hide all active gnomes ---
function hideAllGnomes() {
  for (const idx of activeHoles) {
    const container = holes[idx].querySelector('.gnome-container');
    // Cancel charge if this gnome was being charged
    if (chargeTarget === container) cancelCharge();
    container.classList.remove('visible', 'golden');
  }
  gnomeVisible = false;
  goldenActive = false;
}

// --- Heal gnome on miss ---
function healGnomeOnMiss() {
  const heal = currentDifficulty.missHeal;
  if (heal <= 0) return;
  const before = gnomeHP;
  gnomeHP = Math.min(MAX_HP, gnomeHP + heal);
  if (gnomeHP !== before) updateHUD();
}

// --- Cancel active charge (no penalty) ---
function cancelCharge() {
  if (!chargeTarget) return;
  chargeTarget.classList.remove('charging');
  chargeTarget = null;
  chargeStartTime = 0;
}

// --- Handle press (mousedown / touchstart) ---
function handlePress(x, y, target, isTouch) {
  if (!target) return;

  // Ignore taps on HUD buttons
  if (target.closest('#hud')) return;

  // Check if we pressed on a visible gnome
  const clickedGnome = target.closest('.gnome-container.visible');

  if (clickedGnome) {
    const idx = parseInt(clickedGnome.dataset.index);
    if (!activeHoles.includes(idx)) return;

    // Start charging this gnome
    cancelCharge(); // cancel any prior charge
    chargeTarget = clickedGnome;
    chargeStartTime = Date.now();
    chargeIsTouch = isTouch;

    // Set CSS custom property for ring animation duration
    const durationMs = isTouch ? CHARGE_MS_TOUCH : CHARGE_MS_MOUSE;
    clickedGnome.style.setProperty('--charge-duration', durationMs + 'ms');
    clickedGnome.classList.add('charging');
  } else if (gnomeVisible) {
    // Missed - tapped empty space while gnome(s) showing (instant miss, no charge)
    cancelCharge();
    clearTimeout(gnomeTimeout);
    clearTimeout(relocateTimeout);
    misses++;
    combo = 0;
    updateCombo();
    healGnomeOnMiss();

    // Show laugh on remaining gnomes before hiding
    for (const idx of activeHoles) {
      const container = holes[idx].querySelector('.gnome-container');
      if (container.classList.contains('visible')) {
        showBubble(idx, 'lol üòÇ', 900);
      }
    }
    hideAllGnomes();
    applyMissPenalty(x, y);
    showMissBubble(x, y);
    shakeScreen();
    setTimeout(() => speak('lol'), 100);
  }
}

// --- Handle release (mouseup / touchend) ---
function handleRelease(x, y) {
  if (!chargeTarget) return;

  const target = chargeTarget;
  const elapsed = Date.now() - chargeStartTime;
  const required = chargeIsTouch ? CHARGE_MS_TOUCH : CHARGE_MS_MOUSE;

  // Clean up charging state
  target.classList.remove('charging');
  chargeTarget = null;
  chargeStartTime = 0;

  // If gnome is no longer visible (escaped/relocated during charge), no penalty
  if (!target.classList.contains('visible')) return;

  const idx = parseInt(target.dataset.index);
  if (!activeHoles.includes(idx)) return;

  if (elapsed >= required) {
    // Charge complete ‚Äî process hit!
    processHit(target, idx, x, y);
  } else {
    // Released too early ‚Äî miss!
    misses++;
    combo = 0;
    updateCombo();
    healGnomeOnMiss();
    showMissBubble(x, y);
    applyMissPenalty(x, y);
    showBubble(idx, 'too fast! üòè', 900);
    shakeScreen();
    setTimeout(() => speak('lol'), 100);
  }
}

// --- Process a successful hit on a gnome ---
function processHit(clickedGnome, idx, x, y) {
  clickedGnome.classList.remove('charging');

  // Golden gnome: TRAP ‚Äî no points, combo reset, shuffle holes
  if (goldenActive) {
    clickedGnome.classList.add('hit');
    showBubble(idx, 'lol üòÇ SHUFFLE!', 1200);
    speak('lol');
    shakeScreen();

    combo = 0;
    updateCombo();

    clearTimeout(gnomeTimeout);
    clearTimeout(relocateTimeout);
    clearTimeout(popInterval);
    gnomeVisible = false;
    goldenActive = false;
    updateHUD();

    // Rebuild field after brief delay
    setTimeout(() => {
      if (!gameRunning) return;
      buildField();
      shakeScreen();
      const nextDelay = currentDifficulty.gapMin + rng() * currentDifficulty.gapRange;
      popInterval = setTimeout(spawnGnome, nextDelay);
    }, 500);
    return;
  }

  // Speed bonus: faster reaction = more points (10-100)
  const reactionMs = Date.now() - gnomeAppearedAt;
  const maxWindow = currentDifficulty.visibleMin + currentDifficulty.visibleRange;
  const speedFactor = Math.max(0, 1 - reactionMs / maxWindow);
  const basePoints = Math.ceil(10 + 90 * speedFactor);

  // Combo: consecutive hits multiply points
  combo++;
  const comboMultiplier = Math.min(combo, 5);
  const hitPoints = basePoints * comboMultiplier;

  score += hitPoints;
  hits++;
  roundHitsCount++;

  // Visual feedback for individual gnome
  clickedGnome.classList.add('hit');
  showBubble(idx, 'ouuuuch! üòµ', 900);
  speak('ouuuuch');
  spawnStars(x, y);
  showScorePopup(x, y, hitPoints, comboMultiplier);

  // After hit animation, hide this gnome
  setTimeout(() => {
    clickedGnome.classList.remove('visible', 'hit');
  }, 300);

  const gnomesNeeded = currentDifficulty.gnomesPerRound || 1;

  if (roundHitsCount >= gnomesNeeded) {
    // Round complete - all gnomes hit! HP decreases
    clearTimeout(gnomeTimeout);
    clearTimeout(relocateTimeout);
    gnomeHP--;
    gnomeVisible = false;
    updateHUD();
    updateCombo();

    if (gnomeHP <= 0) {
      endGame();
    }
  } else {
    // Partial hit - still more gnomes to whack this round
    updateHUD();
    updateCombo();
  }
}

// --- HUD update ---
function updateHUD() {
  scoreDisplay.textContent = `Score: ${score}`;
  const pct = (gnomeHP / MAX_HP) * 100;
  healthBar.style.width = pct + '%';
  healthText.textContent = `${gnomeHP}/${MAX_HP}`;

  if (pct <= 30) {
    healthBar.style.background = 'linear-gradient(90deg, #FF0000, #FF4444)';
  } else if (pct <= 60) {
    healthBar.style.background = 'linear-gradient(90deg, #FF8800, #FFAA44)';
  } else {
    healthBar.style.background = 'linear-gradient(90deg, #FF4444, #FF6666)';
  }
}

// --- Score popup at hit location ---
function showScorePopup(x, y, points, comboMult) {
  const popup = document.createElement('div');
  popup.className = 'score-popup';
  popup.textContent = `+${points}` + (comboMult > 1 ? ` x${comboMult}` : '');
  popup.style.left = (x + 20) + 'px';
  popup.style.top = (y - 20) + 'px';
  document.body.appendChild(popup);
  setTimeout(() => popup.remove(), 800);
}

// --- Apply miss penalty ---
function applyMissPenalty(x, y) {
  const penalty = currentDifficulty.missPenalty || 0;
  if (penalty <= 0) return;
  score = Math.max(0, score - penalty);
  const popup = document.createElement('div');
  popup.className = 'score-popup penalty';
  popup.textContent = `-${penalty}`;
  popup.style.left = (x || window.innerWidth / 2) + 'px';
  popup.style.top = (y || window.innerHeight / 2) + 'px';
  document.body.appendChild(popup);
  setTimeout(() => popup.remove(), 800);
  updateHUD();
}

// --- Combo display ---
function updateCombo() {
  if (combo > 1) {
    comboDisplay.textContent = `x${Math.min(combo, 5)} combo${combo >= 5 ? ' MAX' : ''}`;
    comboDisplay.classList.add('active');
  } else {
    comboDisplay.classList.remove('active');
  }
}

// --- Timer ---
function formatTime(ms) {
  const totalSec = Math.floor(ms / 1000);
  const min = Math.floor(totalSec / 60);
  const sec = totalSec % 60;
  const tenths = Math.floor((ms % 1000) / 100);
  return `${min}:${sec.toString().padStart(2, '0')}.${tenths}`;
}

function startTimer() {
  gameStartTime = Date.now();
  timerInterval = setInterval(() => {
    elapsedTime = Date.now() - gameStartTime;
    timerDisplay.textContent = formatTime(elapsedTime);
  }, 100);
}

function stopTimer() {
  clearInterval(timerInterval);
  timerInterval = null;
  elapsedTime = Date.now() - gameStartTime;
}

// --- Spawn stars at hit location ---
function spawnStars(x, y) {
  const emojis = ['‚≠ê', 'üí•', '‚ú®', 'üåü'];
  for (let i = 0; i < 6; i++) {
    const star = document.createElement('div');
    star.className = 'star';
    star.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    star.style.left = x + 'px';
    star.style.top = y + 'px';
    const angle = (Math.PI * 2 * i) / 6;
    const dist = 40 + Math.random() * 50;
    const dx = Math.cos(angle) * dist;
    const dy = Math.sin(angle) * dist;
    star.animate([
      { transform: 'translate(0,0) scale(1)', opacity: 1 },
      { transform: `translate(${dx}px,${dy}px) scale(0.3)`, opacity: 0 }
    ], { duration: 500, easing: 'ease-out' });
    document.body.appendChild(star);
    setTimeout(() => star.remove(), 600);
  }
}

// --- Miss bubble at click location ---
function showMissBubble(x, y) {
  const bubble = document.createElement('div');
  bubble.className = 'miss-bubble';
  bubble.textContent = 'Miss!';
  bubble.style.left = x + 'px';
  bubble.style.top = y + 'px';
  document.body.appendChild(bubble);
  setTimeout(() => bubble.remove(), 1000);
}

// --- Screen shake ---
function shakeScreen() {
  gameScreen.classList.remove('shake');
  void gameScreen.offsetWidth;
  gameScreen.classList.add('shake');
  setTimeout(() => gameScreen.classList.remove('shake'), 300);
}

// --- Stop all timers ---
function stopTimers() {
  clearTimeout(gnomeTimeout);
  clearTimeout(popInterval);
  clearTimeout(relocateTimeout);
  gnomeTimeout = null;
  popInterval = null;
  relocateTimeout = null;
  stopTimer();
}

// --- Start game ---
let lastDifficulty = 'normal';
function startGame(difficulty) {
  if (difficulty) lastDifficulty = difficulty;
  currentDifficulty = DIFFICULTY[lastDifficulty];

  score = 0;
  hits = 0;
  misses = 0;
  combo = 0;
  gnomeHP = MAX_HP;
  activeHoles = [];
  roundHitsCount = 0;
  gnomeVisible = false;
  cancelCharge();
  rng = mulberry32(dateSeed(todayStr, lastDifficulty));
  gameRunning = true;

  // Apply difficulty grass color
  const g = currentDifficulty.grass;
  gameScreen.style.background = `linear-gradient(180deg, ${g[0]} 0%, ${g[1]} 40%, ${g[2]} 100%)`;

  buildField();
  updateHUD();
  updateCombo();
  timerDisplay.textContent = '0:00.0';
  titleScreen.classList.add('hidden');
  gameScreen.classList.add('active');
  gameOver.classList.remove('active');

  startTimer();
  startMusic();
  setTimeout(spawnGnome, 1000);
}

// --- Quit game (back to title) ---
function quitGame() {
  gameRunning = false;
  cancelCharge();
  stopTimers();
  stopMusic();
  gnomeVisible = false;

  document.querySelectorAll('.gnome-container').forEach(c => {
    c.classList.remove('visible', 'hit', 'charging', 'golden');
  });

  gameScreen.classList.remove('active');
  titleScreen.classList.remove('hidden');
}

// --- End game ---
function endGame() {
  gameRunning = false;
  cancelCharge();
  stopTimers();
  stopMusic();
  gnomeVisible = false;

  document.querySelectorAll('.gnome-container').forEach(c => {
    c.classList.remove('visible', 'hit', 'charging', 'golden');
  });

  setTimeout(() => {
    const accuracy = hits > 0 ? Math.round(hits / (hits + misses) * 100) : 0;
    const elapsedSec = elapsedTime / 1000;
    const timeBonus = Math.max(0, Math.floor(2000 - elapsedSec * 20));
    const finalScore = score + timeBonus;
    document.getElementById('final-difficulty').textContent = `${currentDifficulty.label} Mode`;
    document.getElementById('final-time').textContent = `Time: ${formatTime(elapsedTime)}`;
    document.getElementById('final-score').textContent = `Final Score: ${finalScore}`;
    document.getElementById('final-bonus').textContent =
      `Hit points: ${score}  +  Time bonus: ${timeBonus}`;
    document.getElementById('final-detail').textContent =
      `${hits} hits, ${misses} misses  |  Accuracy: ${accuracy}%`;
    document.getElementById('final-seed').textContent = 'Daily Seed: ' + todayStr;
    gameOver.classList.add('active');
    speak('oh no!');
  }, 500);
}

// --- Restart ---
function restartGame() {
  gameOver.classList.remove('active');
  startGame();
}
</script>
</body>
</html>
