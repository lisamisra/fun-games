<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Dungeon Doom - Escape the Boulder!</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    touch-action: manipulation;
    font-family: 'Trebuchet MS', system-ui, -apple-system, 'Segoe UI', sans-serif;
    height: 100%;
    background: #1a0a1e;
  }

  /* --- Title Screen --- */
  #title-screen {
    position: fixed; inset: 0;
    background: linear-gradient(180deg, #1a0a2e 0%, #2d1b4e 40%, #1a0a1e 100%);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100;
    transition: opacity 0.5s;
  }
  #title-screen.hidden { opacity: 0; pointer-events: none; }
  #title-screen h1 {
    font-size: 3.5rem; color: #FF6347;
    text-shadow: 3px 3px 0 #8B0000, 0 0 20px rgba(255,99,71,0.5);
    margin-bottom: 0.3rem;
    animation: title-pulse 2s infinite alternate;
  }
  #title-screen .subtitle {
    font-size: 1.3rem; color: #ccc; margin-bottom: 0.4rem;
  }
  #title-screen .daily-seed {
    font-size: 0.95rem; color: #888; margin-bottom: 1.2rem;
  }
  #title-screen .dungeon-preview {
    font-size: 4rem; margin-bottom: 1rem;
  }
  #difficulty-pick {
    display: flex; flex-wrap: wrap; justify-content: center;
    gap: 1rem; margin-bottom: 1rem;
  }
  .diff-btn {
    font-size: 1.3rem; padding: 0.5em 1.4em;
    background: #2d1b4e; color: #ddd;
    border: 3px solid #5a3d7a; border-radius: 12px;
    font-family: inherit; font-weight: bold;
    box-shadow: 0 4px 0 #3d2555;
    transition: transform 0.1s, box-shadow 0.1s, background 0.15s;
    cursor: pointer;
  }
  .diff-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 #3d2555; }
  .diff-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #3d2555; }
  .diff-btn.easy { background: #2E7D32; color: #fff; border-color: #1B5E20; box-shadow: 0 4px 0 #1B5E20; }
  .diff-btn.easy:hover { box-shadow: 0 6px 0 #1B5E20; }
  .diff-btn.easy:active { box-shadow: 0 2px 0 #1B5E20; }
  .diff-btn.normal { background: #E65100; color: #fff; border-color: #BF360C; box-shadow: 0 4px 0 #BF360C; }
  .diff-btn.normal:hover { box-shadow: 0 6px 0 #BF360C; }
  .diff-btn.normal:active { box-shadow: 0 2px 0 #BF360C; }
  .diff-btn.hard { background: #B71C1C; color: #fff; border-color: #7f0000; box-shadow: 0 4px 0 #7f0000; }
  .diff-btn.hard:hover { box-shadow: 0 6px 0 #7f0000; }
  .diff-btn.hard:active { box-shadow: 0 2px 0 #7f0000; }
  .diff-btn.achal { background: #9B59B6; color: #fff; border-color: #6C3483; box-shadow: 0 4px 0 #6C3483;
    display: inline-flex; align-items: center; gap: 0.4em; }
  .diff-btn.achal:hover { box-shadow: 0 6px 0 #6C3483; }
  .diff-btn.achal:active { box-shadow: 0 2px 0 #6C3483; }
  .diff-btn.achal img {
    width: 1.6em; height: 1.6em; border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.6); object-fit: cover;
  }
  .home-link {
    display: inline-block; font-size: 1.2rem; padding: 0.4em 1em;
    background: rgba(255,255,255,0.1); color: #ccc;
    border: 2px solid rgba(255,255,255,0.2); border-radius: 10px;
    text-decoration: none; font-weight: bold; font-family: inherit;
    transition: background 0.15s; cursor: pointer;
  }
  .home-link:hover { background: rgba(255,255,255,0.2); }
  #title-screen .home-link { margin-top: 1rem; }

  /* --- Controls Guide --- */
  .controls-guide {
    display: flex; flex-wrap: wrap; justify-content: center;
    gap: 0.6rem 1.4rem; margin-bottom: 1.2rem;
    max-width: 420px;
  }
  .control-item {
    display: flex; align-items: center; gap: 0.4rem;
    font-size: 0.95rem; color: #aaa;
  }
  .control-item kbd {
    background: rgba(255,255,255,0.15); color: #fff;
    padding: 0.15em 0.5em; border-radius: 5px;
    font-family: inherit; font-size: 0.85rem; font-weight: bold;
    border: 1px solid rgba(255,255,255,0.25);
  }


  /* --- Intro elements (inside dungeon) --- */
  #intro-scared {
    position: absolute;
    font-size: 2rem; z-index: 12;
    opacity: 0; transition: opacity 0.2s;
    pointer-events: none;
  }
  #intro-scared.visible {
    opacity: 1;
    animation: scared-bob 0.3s infinite alternate;
  }
  @keyframes scared-bob {
    from { transform: translateY(0); }
    to { transform: translateY(-6px); }
  }
  #intro-text {
    position: absolute; left: 50%; top: 35%;
    transform: translateX(-50%);
    color: #FF6347; font-size: 2.5rem; font-weight: bold;
    opacity: 0; transition: opacity 0.4s;
    text-shadow: 0 0 20px rgba(255,99,71,0.6), 2px 2px 0 #000;
    pointer-events: none; z-index: 15;
    white-space: nowrap;
  }
  #intro-text.visible { opacity: 1; }

  /* --- Game Screen --- */
  #game-screen {
    position: fixed; inset: 0;
    display: none; overflow: hidden;
    background: #0a0510;
  }
  #game-screen.active {
    display: flex; align-items: center; justify-content: center;
  }

  /* --- Game Viewport (constrained) --- */
  #game-viewport {
    position: relative;
    width: 100%; max-width: 900px;
    height: 100%; max-height: 520px;
    overflow: hidden;
    border-radius: 4px;
  }

  /* --- Dungeon --- */
  #dungeon {
    position: absolute; inset: 0;
    background: linear-gradient(180deg, #1a0a1e 0%, #2d1520 50%, #1a0a1e 100%);
    overflow: hidden;
  }
  #ceiling {
    position: absolute; top: 0; left: 0; right: 0;
    height: 15%; background: linear-gradient(180deg, #0d0508 0%, #1a0a10 100%);
    border-bottom: 3px solid #3d1520;
  }
  #ground {
    position: absolute; bottom: 0; left: 0; right: 0;
    height: 25%; background: linear-gradient(0deg, #2d1520 0%, #3d1a28 50%, #4d2030 100%);
    border-top: 3px solid #6d3040;
  }
  #ground::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; height: 4px;
    background: repeating-linear-gradient(90deg, #6d3040 0px, #8d4050 20px, #6d3040 40px);
  }

  /* Torch lighting overlay */
  #torch-overlay {
    position: absolute; inset: 0;
    pointer-events: none; z-index: 5;
    will-change: transform;
  }

  /* Wall torches */
  .wall-torch {
    position: absolute; left: 0; top: 0;
    font-size: 2rem; z-index: 2;
    will-change: transform;
    animation: torch-flicker 0.3s infinite alternate;
  }
  @keyframes torch-flicker {
    from { opacity: 0.85; }
    to { opacity: 1; }
  }

  /* --- Player --- */
  #player {
    position: absolute; left: 0; top: 0;
    z-index: 10;
    font-size: 3rem; line-height: 1;
    will-change: transform;
  }
  #player .player-sprite {
    display: inline-block;
  }
  #player.invincible .player-sprite { animation: blink 0.15s infinite alternate !important; }
  #player.spinning .player-sprite { animation: spin 0.5s linear !important; }
  @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

  /* --- Boulder --- */
  #boulder {
    position: absolute; left: 0; top: 0;
    font-size: 4.5rem; z-index: 8;
    will-change: transform;
  }
  #boulder .boulder-sprite {
    display: inline-block;
    animation: boulder-roll 0.6s linear infinite;
    will-change: transform;
  }
  @keyframes boulder-roll {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  /* --- Bats (decorative) --- */
  .bat {
    position: absolute; left: 0; top: 0;
    font-size: 1.4rem; z-index: 3;
    will-change: transform;
    pointer-events: none;
    opacity: 0.6;
  }
  .bat .bat-inner {
    display: inline-block;
    animation: bat-flap 0.25s steps(1) infinite;
  }
  @keyframes bat-flap {
    0%   { transform: scaleY(1); }
    50%  { transform: scaleY(0.5); }
  }

  /* --- Obstacles --- */
  .obstacle {
    position: absolute; left: 0; top: 0;
    font-size: 2.5rem; z-index: 9;
    will-change: transform;
  }
  .obstacle.fire-pit .obs-inner {
    display: inline-block;
    animation: fire-animate 0.2s infinite alternate;
    transform-origin: bottom center;
  }
  @keyframes fire-animate {
    0%   { transform: scaleY(1) scaleX(1); }
    50%  { transform: scaleY(1.25) scaleX(0.88); }
    100% { transform: scaleY(0.9) scaleX(1.06); }
  }
  .obstacle.arrow-projectile {
    font-size: 1.8rem;
    font-weight: bold;
    color: #ddd;
    text-shadow: 4px 0 8px rgba(255,150,50,0.6), 8px 0 16px rgba(255,100,0,0.3);
    letter-spacing: -3px;
  }

  /* --- Center Hint (flashes before obstacle reaches player) --- */
  #center-hint {
    position: absolute; z-index: 25;
    left: 50%; top: 38%;
    transform: translate(-50%, -50%) scale(1);
    font-size: 2.5rem; font-weight: bold;
    color: #4f4; pointer-events: none;
    text-shadow: 0 0 20px rgba(50,255,50,0.6), 2px 2px 0 #000;
    opacity: 0;
    transition: opacity 0.15s;
    white-space: nowrap;
  }
  #center-hint.visible {
    opacity: 1;
    animation: hint-pulse 0.4s ease-out;
  }
  @keyframes hint-pulse {
    from { transform: translate(-50%, -50%) scale(1.4); }
    to { transform: translate(-50%, -50%) scale(1); }
  }

  /* --- Pickups --- */
  .pickup {
    position: absolute; left: 0; top: 0;
    font-size: 2.2rem; z-index: 9;
    will-change: transform;
  }
  .pickup .pickup-inner {
    display: inline-block;
    animation: pickup-bob 0.6s infinite alternate ease-in-out;
  }
  @keyframes pickup-bob {
    from { transform: translateY(0); }
    to { transform: translateY(-8px); }
  }

  /* --- Fireballs (player-thrown) --- */
  .fireball-projectile {
    position: absolute; left: 0; top: 0;
    font-size: 2rem; z-index: 11;
    will-change: transform;
  }

  /* --- HUD --- */
  #hud {
    position: absolute; top: 0; left: 0; right: 0;
    display: flex; justify-content: space-between; align-items: flex-start;
    padding: 0.6rem 1rem; z-index: 20;
    flex-wrap: wrap; gap: 0.4rem;
  }
  #hud-left { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
  #hud-right { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
  .hud-item {
    font-size: 1.1rem; font-weight: bold; color: #fff;
    background: rgba(0,0,0,0.6); padding: 0.3em 0.7em;
    border-radius: 10px; white-space: nowrap;
  }
  .hud-btn {
    font-size: 1.1rem; padding: 0.3em 0.7em;
    background: rgba(0,0,0,0.5); color: #fff;
    border: 2px solid rgba(255,255,255,0.25); border-radius: 10px;
    font-family: inherit; font-weight: bold;
    transition: background 0.15s; cursor: pointer;
  }
  .hud-btn:hover { background: rgba(0,0,0,0.7); }

  /* Boulder HP bar */
  #boulder-hp-container {
    display: flex; align-items: center; gap: 0.4rem;
    background: rgba(0,0,0,0.6); padding: 0.3em 0.7em; border-radius: 10px;
  }
  #boulder-hp-bar-bg {
    width: 120px; height: 16px; background: #333;
    border-radius: 8px; overflow: hidden; border: 2px solid #555;
  }
  #boulder-hp-bar {
    width: 100%; height: 100%;
    background: linear-gradient(90deg, #8B0000, #FF4444);
    border-radius: 8px; transition: width 0.3s;
  }
  #boulder-hp-text { font-size: 0.9rem; color: #fff; min-width: 2.5em; }

  /* --- Controls (overlaid at bottom of dungeon) --- */
  #controls {
    position: absolute; bottom: 0; left: 0; right: 0;
    display: none; justify-content: space-between;
    align-items: flex-end;
    padding: 0.6rem 1rem;
    padding-bottom: calc(0.6rem + env(safe-area-inset-bottom, 0px));
    z-index: 20;
  }
  #controls.active { display: flex; }
  .ctrl-btn {
    font-size: 1.2rem; padding: 0.7em 1.1em;
    background: rgba(255,255,255,0.12); color: #fff;
    border: 2px solid rgba(255,255,255,0.25); border-radius: 12px;
    font-family: inherit; font-weight: bold;
    transition: background 0.1s; cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    min-width: 3.5em; text-align: center;
  }
  .ctrl-btn:active, .ctrl-btn.pressed {
    background: rgba(255,255,255,0.35);
    transform: scale(0.95);
  }
  #controls-left { display: flex; gap: 0.5rem; }
  #controls-right { display: flex; gap: 0.5rem; }
  .ctrl-btn.jump-btn { background: rgba(50,200,50,0.2); border-color: rgba(50,200,50,0.4); }
  .ctrl-btn.duck-btn { background: rgba(50,100,200,0.2); border-color: rgba(50,100,200,0.4); }
  .ctrl-btn.destroy-btn { background: rgba(255,80,0,0.2); border-color: rgba(255,80,0,0.4); }

  /* --- Game Over / Victory Screen --- */
  #game-over {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.85);
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 300;
  }
  #game-over.active { display: flex; }
  #game-over h2 {
    font-size: 3rem; margin-bottom: 0.5rem;
    animation: title-pulse 1.5s infinite alternate;
  }
  #game-over h2.victory { color: #FFD700; text-shadow: 2px 2px 4px #000, 0 0 20px rgba(255,215,0,0.5); }
  #game-over h2.defeat { color: #FF4444; text-shadow: 2px 2px 4px #000, 0 0 20px rgba(255,68,68,0.5); }
  #game-over .stat-line {
    font-size: 1.3rem; color: #ccc; margin-bottom: 0.3rem;
  }
  #game-over .stat-line.big {
    font-size: 1.6rem; color: #fff; margin-bottom: 0.5rem;
  }
  .go-buttons { display: flex; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap; justify-content: center; }
  .green-btn {
    font-size: 1.4rem; padding: 0.6em 1.6em;
    background: #4CAF50; color: white;
    border: 4px solid #2E7D32; border-radius: 14px;
    font-family: inherit; font-weight: bold;
    box-shadow: 0 5px 0 #2E7D32;
    transition: transform 0.1s, box-shadow 0.1s; cursor: pointer;
  }
  .green-btn:hover { transform: translateY(-2px); box-shadow: 0 7px 0 #2E7D32; }
  .green-btn:active { transform: translateY(3px); box-shadow: 0 2px 0 #2E7D32; }

  /* --- Screen shake --- */
  #game-viewport.shake { animation: shake 0.3s ease-out; }

  /* --- Animations --- */
  @keyframes title-pulse {
    from { transform: scale(1); }
    to { transform: scale(1.05); }
  }
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-6px) rotate(-0.5deg); }
    40% { transform: translateX(6px) rotate(0.5deg); }
    60% { transform: translateX(-4px); }
    80% { transform: translateX(4px); }
  }

  /* --- Responsive --- */
  @media (max-width: 600px) {
    #title-screen h1 { font-size: 2.4rem; }
    #title-screen .subtitle { font-size: 1rem; }
    #title-screen .dungeon-preview { font-size: 3rem; }
    .diff-btn { font-size: 1.1rem; padding: 0.4em 1em; }
    #hud { padding: 0.4rem 0.5rem; }
    .hud-item { font-size: 0.9rem; padding: 0.2em 0.5em; }
    .hud-btn { font-size: 0.9rem; padding: 0.2em 0.5em; }
    #boulder-hp-bar-bg { width: 80px; height: 14px; }
    #boulder-hp-text { font-size: 0.8rem; }
    #player { font-size: 2.2rem; }
    #boulder { font-size: 3.5rem; }
    .obstacle { font-size: 2rem; }
    .pickup { font-size: 1.8rem; }
    .ctrl-btn { font-size: 1rem; padding: 0.6em 0.8em; min-width: 3em; }
    #game-over h2 { font-size: 2.2rem; }
    #game-over .stat-line { font-size: 1.1rem; }
    #game-over .stat-line.big { font-size: 1.3rem; }
    .green-btn { font-size: 1.2rem; padding: 0.5em 1.2em; }
  }

  @media (max-width: 380px) {
    .ctrl-btn { font-size: 0.9rem; padding: 0.5em 0.6em; min-width: 2.5em; }
    #controls { padding: 0.4rem 0.5rem; gap: 0.3rem; }
    #controls-left { gap: 0.3rem; }
    #hud { gap: 0.2rem; }
  }

  /* --- iOS safe area padding --- */
  @supports (padding-top: env(safe-area-inset-top)) {
    #hud { padding-top: calc(0.4rem + env(safe-area-inset-top)); }
  }
</style>
</head>
<body>

<!-- Title Screen -->
<div id="title-screen">
  <div class="dungeon-preview">üè∞üî•‚öîÔ∏è</div>
  <h1>Dungeon Doom</h1>
  <p class="subtitle">Outrun the boulder. Destroy it with fire!</p>
  <p class="daily-seed" id="daily-seed"></p>
  <div class="controls-guide">
    <div class="control-item"><kbd>Space</kbd> / <kbd>Up</kbd> Jump</div>
    <div class="control-item"><kbd>Ctrl</kbd> / <kbd>Down</kbd> Duck</div>
    <div class="control-item"><kbd>V</kbd> Spin Jump</div>
    <div class="control-item"><kbd>D</kbd> Throw Fire</div>
  </div>
  <div id="difficulty-pick">
    <button class="diff-btn easy" onclick="beginGame('easy')">Easy</button>
    <button class="diff-btn normal" onclick="beginGame('normal')">Normal</button>
    <button class="diff-btn hard" onclick="beginGame('hard')">Hard</button>
    <button class="diff-btn achal" onclick="beginGame('achal')"><img src="achal-anna.png" alt="">Achal Anna</button>
  </div>
  <a href="index.html" class="home-link">Back to Games</a>
</div>

<!-- Game Screen -->
<div id="game-screen">
  <div id="game-viewport">
    <div id="hud">
      <div id="hud-left">
        <button class="hud-btn" id="quit-btn" onclick="quitGame()">Quit</button>
        <button class="hud-btn" id="mute-btn" onclick="toggleMute()">üîä</button>
        <div class="hud-item" id="score-display">Score: 0</div>
        <div class="hud-item" id="hearts-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      </div>
      <div id="hud-right">
        <div class="hud-item" id="fireball-display">üî• 0</div>
        <div id="boulder-hp-container">
          <span style="font-size:1.2rem">ü™®</span>
          <div id="boulder-hp-bar-bg"><div id="boulder-hp-bar"></div></div>
          <span id="boulder-hp-text">10/10</span>
        </div>
      </div>
    </div>

    <div id="dungeon">
      <div id="ceiling"></div>
      <div id="ground"></div>
      <div id="torch-overlay"></div>
      <div id="boulder"><span class="boulder-sprite">ü™®</span></div>
      <div id="player"><span class="player-sprite">üèÉ</span></div>
      <div id="center-hint"></div>
      <div id="intro-scared">üò®</div>
      <div id="intro-text">RUN!!!</div>
    </div>

    <div id="controls">
      <div id="controls-left">
        <button class="ctrl-btn jump-btn" id="btn-jump">Jump</button>
        <button class="ctrl-btn duck-btn" id="btn-duck">Duck</button>
      </div>
      <div id="controls-right">
        <button class="ctrl-btn destroy-btn" id="btn-destroy">üî• Fire</button>
      </div>
    </div>
  </div>
</div>

<!-- Game Over Screen -->
<div id="game-over">
  <h2 id="go-title">Victory!</h2>
  <div class="stat-line big" id="go-score"></div>
  <div class="stat-line" id="go-difficulty"></div>
  <div class="stat-line" id="go-time"></div>
  <div class="stat-line" id="go-obstacles"></div>
  <div class="stat-line" id="go-fireballs"></div>
  <div class="go-buttons">
    <button class="green-btn" onclick="restartGame()">Play Again!</button>
    <a href="index.html" class="home-link">Back to Games</a>
  </div>
</div>

<script>
// ============================================================
// SEEDED RNG
// ============================================================
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
function dateSeed(dateStr, difficulty) {
  let h = 0;
  const s = dateStr + ':' + difficulty;
  for (let i = 0; i < s.length; i++) {
    h = Math.imul(31, h) + s.charCodeAt(i) | 0;
  }
  return h;
}
function getTodayStr() {
  const d = new Date();
  return d.getUTCFullYear() + '-' +
    String(d.getUTCMonth() + 1).padStart(2, '0') + '-' +
    String(d.getUTCDate()).padStart(2, '0');
}

let rng = null; // seeded random, replaces Math.random() during gameplay

// Show today's date on title
document.getElementById('daily-seed').textContent = 'Daily Dungeon: ' + getTodayStr();

// ============================================================
// DIFFICULTY PRESETS
// ============================================================
const BOULDER_MAX_HP = parseInt(new URLSearchParams(window.location.search).get('hp')) || 10;
const DIFFICULTY = {
  easy: {
    label: 'Easy', startSpeed: 2.5, maxSpeed: 5, rampRate: 0.0003,
    spawnInterval: 2.2, spawnVariance: 0.8,
    chestChance: 0.18, heartChance: 0.1,
    colors: { bg1: '#1a0a2e', bg2: '#2d1b4e', bg3: '#1a0a2e',
              ground1: '#2d1520', ground2: '#3d1a28', ground3: '#4d2030',
              ceiling: '#0d0508', border: '#3d1520' }
  },
  normal: {
    label: 'Normal', startSpeed: 3.5, maxSpeed: 7, rampRate: 0.0005,
    spawnInterval: 1.8, spawnVariance: 0.6,
    chestChance: 0.14, heartChance: 0.07,
    colors: { bg1: '#1a0a1e', bg2: '#2d1520', bg3: '#1a0a1e',
              ground1: '#2d1520', ground2: '#3d1a28', ground3: '#4d2030',
              ceiling: '#0d0508', border: '#3d1520' }
  },
  hard: {
    label: 'Hard', startSpeed: 5, maxSpeed: 9, rampRate: 0.0008,
    spawnInterval: 1.4, spawnVariance: 0.4,
    chestChance: 0.20, heartChance: 0.12,
    misleadChance: 0.25, comboChance: 0.3,
    colors: { bg1: '#1e0505', bg2: '#3d0a0a', bg3: '#1e0505',
              ground1: '#3d0a0a', ground2: '#4d1515', ground3: '#5d2020',
              ceiling: '#0d0202', border: '#5d1010' }
  },
  achal: {
    label: 'Achal Anna', startSpeed: 9, maxSpeed: 9, rampRate: 0,
    spawnInterval: 1.2, spawnVariance: 0.3,
    chestChance: 0.25, heartChance: 0.15,
    misleadChance: 0.25, comboChance: 0.45,
    colors: { bg1: '#1a0a2e', bg2: '#3d1560', bg3: '#1a0a2e',
              ground1: '#2d1050', ground2: '#4d1a70', ground3: '#5d2080',
              ceiling: '#0d0518', border: '#5d2080' }
  }
};

// ============================================================
// OBSTACLE TYPES
// ============================================================
const OBSTACLE_TYPES = [
  { id: 'fire_pit',   emoji: 'üî•', position: 'ground', dodge: 'jump',  label: 'Fire Pit', cssClass: 'fire-pit' },
  { id: 'snake',      emoji: 'üêç', position: 'ground', dodge: 'jump',  label: 'Snake' },
  { id: 'wall_blade', emoji: 'üó°Ô∏è', position: 'head',   dodge: 'duck',  label: 'Wall Blade' },
  { id: 'arrow_high', emoji: '‚óÑ‚îÅ‚îÅ', position: 'head',   dodge: 'duck',  label: 'Arrow (high)', cssClass: 'arrow-projectile' },
  { id: 'arrow_low',  emoji: '‚óÑ‚îÅ‚îÅ', position: 'ground', dodge: 'jump',  label: 'Arrow (low)', cssClass: 'arrow-projectile' },
];

// ============================================================
// GAME STATE
// ============================================================
let currentDiff = null;
let lastDiffKey = 'normal';
let gameRunning = false;
let gameStartTime = 0;
let elapsedMs = 0;
let score = 0;
let obstaclesDodged = 0;
let fireballsThrown = 0;

// Player
let playerHearts = 3;
let playerMaxHearts = 3;
let playerY = 0; // 0 = ground level
let playerVelY = 0;
let playerJumping = false;
let playerDucking = false;
let duckTimer = 0;
const DUCK_DURATION = 0.6; // same as jump airtime
let playerSpinning = false;
let spinTimer = 0;
let invincibleTimer = 0;
let fireballs = 0;

// Boulder
let boulderHP = BOULDER_MAX_HP;

// Speed
let currentSpeed = 3;

// Entities
let obstacles = [];
let pickups = [];
let projectiles = [];

// Spawning
let spawnTimer = 0;
let pickupTimer = 0;
let nextSpawnTime = 0;
let nextPickupTime = 0;

// Torch
let torchOffsetX = 0;
let wallTorches = [];

// Input
let inputJump = false;
let inputDuck = false;
let inputDestroy = false;
let jumpPressed = false;
let duckPressed = false;
let destroyPressed = false;
// Track individual keys for V-key overlap handling
let keysDown = {};

// Layout
let groundY = 0;
let ceilingY = 0;
let playerX = 0;
let boulderX = 0;
let dungeonW = 0;
let dungeonH = 0;
let playerSize = 0;
let entitySize = 0;
let boulderSize = 0;

// Touch control detection
const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

// DOM
const titleScreen = document.getElementById('title-screen');
const introScaredEl = document.getElementById('intro-scared');
const introTextEl = document.getElementById('intro-text');
const gameScreen = document.getElementById('game-screen');
const gameOverScreen = document.getElementById('game-over');
const dungeon = document.getElementById('dungeon');
const playerEl = document.getElementById('player');
const boulderEl = document.getElementById('boulder');
const controlsEl = document.getElementById('controls');
const hudScore = document.getElementById('score-display');
const hudHearts = document.getElementById('hearts-display');
const hudFireballs = document.getElementById('fireball-display');
const boulderHPBar = document.getElementById('boulder-hp-bar');
const boulderHPText = document.getElementById('boulder-hp-text');
const muteBtn = document.getElementById('mute-btn');
const torchOverlay = document.getElementById('torch-overlay');
const playerSprite = playerEl.querySelector('.player-sprite');
const boulderSprite = boulderEl.querySelector('.boulder-sprite');
const centerHint = document.getElementById('center-hint');
let activeHintObs = null; // track which obstacle we're currently hinting for

// Mute state
let muted = localStorage.getItem('dungeon-muted') === 'true';
function updateMuteBtn() { muteBtn.textContent = muted ? 'üîá' : 'üîä'; }
function toggleMute() {
  muted = !muted;
  localStorage.setItem('dungeon-muted', muted);
  updateMuteBtn();
  if (muted) stopMusic();
  else if (gameRunning) startMusic();
}
updateMuteBtn();

// ============================================================
// AUDIO (Web Audio API - all procedural)
// ============================================================
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}
function unlockAudio() {
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const buf = ctx.createBuffer(1, 1, 22050);
  const src = ctx.createBufferSource();
  src.buffer = buf; src.connect(ctx.destination); src.start(0);
}
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('click', unlockAudio, { once: true });

function playJump() {
  if (muted) return;
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const g = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.15);
  g.gain.setValueAtTime(0.2, ctx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
  osc.connect(g); g.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.2);
}

function playDuck() {
  if (muted) return;
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const g = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(500, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.15);
  g.gain.setValueAtTime(0.15, ctx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
  osc.connect(g); g.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.15);
}

function playSpin() {
  if (muted) return;
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const g = ctx.createGain();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.3);
  g.gain.setValueAtTime(0.15, ctx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.35);
  osc.connect(g); g.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.35);
}

function playHit() {
  if (muted) return;
  const ctx = getAudioCtx();
  // Impact noise
  const bufSize = Math.floor(ctx.sampleRate * 0.15);
  const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) {
    const t = i / bufSize;
    data[i] = (Math.random() * 2 - 1) * (1 - t) * 0.5;
  }
  const src = ctx.createBufferSource(); src.buffer = buf;
  const lp = ctx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 800;
  const g = ctx.createGain(); g.gain.value = 0.4;
  src.connect(lp); lp.connect(g); g.connect(ctx.destination);
  src.start();
  // Descending tone
  const osc = ctx.createOscillator();
  const g2 = ctx.createGain();
  osc.type = 'square'; osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.3);
  g2.gain.setValueAtTime(0.2, ctx.currentTime);
  g2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
  osc.connect(g2); g2.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.3);
}

function playFireball() {
  if (muted) return;
  const ctx = getAudioCtx();
  // Crackle noise
  const bufSize = Math.floor(ctx.sampleRate * 0.2);
  const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) {
    const t = i / bufSize;
    data[i] = (Math.random() * 2 - 1) * (1 - t * 0.5) * 0.3;
  }
  const src = ctx.createBufferSource(); src.buffer = buf;
  const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 2000; bp.Q.value = 1;
  const g = ctx.createGain(); g.gain.value = 0.3;
  src.connect(bp); bp.connect(g); g.connect(ctx.destination);
  src.start();
  // Rising tone
  const osc = ctx.createOscillator();
  const g2 = ctx.createGain();
  osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.15);
  g2.gain.setValueAtTime(0.15, ctx.currentTime);
  g2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
  osc.connect(g2); g2.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.2);
}

function playBoulderHit() {
  if (muted) return;
  const ctx = getAudioCtx();
  // Big impact
  const osc = ctx.createOscillator();
  const g = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(120, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.4);
  g.gain.setValueAtTime(0.4, ctx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
  osc.connect(g); g.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.4);
  // Crunch
  const bufSize = Math.floor(ctx.sampleRate * 0.1);
  const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i/bufSize) * 0.4;
  const src = ctx.createBufferSource(); src.buffer = buf;
  const g2 = ctx.createGain(); g2.gain.value = 0.3;
  src.connect(g2); g2.connect(ctx.destination); src.start();
}

function playChestOpen() {
  if (muted) return;
  const ctx = getAudioCtx();
  const notes = [523, 659, 784];
  notes.forEach((f, i) => {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'triangle'; osc.frequency.value = f;
    const t = ctx.currentTime + i * 0.08;
    g.gain.setValueAtTime(0.2, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
    osc.connect(g); g.connect(ctx.destination);
    osc.start(t); osc.stop(t + 0.15);
  });
}

function playHeartCollect() {
  if (muted) return;
  const ctx = getAudioCtx();
  const notes = [659, 880, 1047];
  notes.forEach((f, i) => {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'sine'; osc.frequency.value = f;
    const t = ctx.currentTime + i * 0.1;
    g.gain.setValueAtTime(0.2, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    osc.connect(g); g.connect(ctx.destination);
    osc.start(t); osc.stop(t + 0.2);
  });
}

function playBoulderDrop() {
  if (muted) return;
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const g = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(80, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.6);
  g.gain.setValueAtTime(0.5, ctx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.7);
  osc.connect(g); g.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.7);
  // Rumble noise
  const bufSize = Math.floor(ctx.sampleRate * 0.5);
  const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) {
    const t = i / bufSize;
    data[i] = (Math.random() * 2 - 1) * Math.max(0, 1 - t * 1.5) * 0.3;
  }
  const src = ctx.createBufferSource(); src.buffer = buf;
  const lp = ctx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 200;
  const g2 = ctx.createGain(); g2.gain.value = 0.4;
  src.connect(lp); lp.connect(g2); g2.connect(ctx.destination); src.start();
}

function playVictory() {
  if (muted) return;
  const ctx = getAudioCtx();
  const melody = [523, 659, 784, 1047, 784, 1047, 1319];
  melody.forEach((f, i) => {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'square'; osc.frequency.value = f;
    const t = ctx.currentTime + i * 0.15;
    g.gain.setValueAtTime(0.15, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    osc.connect(g); g.connect(ctx.destination);
    osc.start(t); osc.stop(t + 0.25);
  });
}

function playGameOver() {
  if (muted) return;
  const ctx = getAudioCtx();
  const melody = [392, 349, 311, 262];
  melody.forEach((f, i) => {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'triangle'; osc.frequency.value = f;
    const t = ctx.currentTime + i * 0.25;
    g.gain.setValueAtTime(0.2, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.35);
    osc.connect(g); g.connect(ctx.destination);
    osc.start(t); osc.stop(t + 0.4);
  });
}

// --- Background Music ---
let musicPlaying = false;
let musicInterval = null;
let musicGain = null;

function startMusic() {
  if (musicPlaying || muted) return;
  const ctx = getAudioCtx();
  musicPlaying = true;
  musicGain = ctx.createGain();
  musicGain.gain.value = 0.10;
  musicGain.connect(ctx.destination);

  const BPM = 140;
  const eighth = 60 / BPM / 2;
  let nextTime = ctx.currentTime + 0.05;
  let step = 0;

  // D minor dark dungeon melody
  const melody = [
    293, 0, 349, 0, 440, 349, 293, 0,
    262, 0, 293, 349, 293, 262, 220, 0,
    293, 0, 349, 440, 523, 0, 440, 349,
    293, 0, 262, 0, 220, 196, 220, 0,
  ];
  const bass = [
    73, 73, 73, 87, 87, 87, 65, 65,
    73, 73, 87, 87, 98, 98, 73, 73,
  ];

  function playNote(freq, time, dur, type, dest) {
    if (!freq) return;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    g.gain.setValueAtTime(0.4, time);
    g.gain.exponentialRampToValueAtTime(0.01, time + dur);
    osc.connect(g); g.connect(dest);
    osc.start(time); osc.stop(time + dur + 0.01);
  }

  function playKick(time) {
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(120, time);
    osc.frequency.exponentialRampToValueAtTime(25, time + 0.15);
    g.gain.setValueAtTime(0.6, time);
    g.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
    osc.connect(g); g.connect(musicGain);
    osc.start(time); osc.stop(time + 0.21);
  }

  function playHat(time, loud) {
    const bufSize = Math.floor(ctx.sampleRate * 0.03);
    const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufSize);
    const src = ctx.createBufferSource(); src.buffer = buf;
    const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 9000;
    const g = ctx.createGain(); g.gain.value = loud ? 0.4 : 0.2;
    src.connect(hp); hp.connect(g); g.connect(musicGain);
    src.start(time);
  }

  function scheduler() {
    if (!musicPlaying) return;
    while (nextTime < ctx.currentTime + 0.25) {
      const mIdx = step % melody.length;
      const bIdx = Math.floor(step / 2) % bass.length;
      // Melody (sawtooth for dark feel)
      playNote(melody[mIdx], nextTime, eighth * 1.5, 'sawtooth', musicGain);
      // Bass every other step
      if (step % 2 === 0) playNote(bass[bIdx], nextTime, eighth * 3, 'square', musicGain);
      // Kick on 1 and 3
      if (step % 8 === 0 || step % 8 === 4) playKick(nextTime);
      // Hi-hat
      if (step % 2 === 0) playHat(nextTime, step % 4 === 2);
      step++;
      nextTime += eighth;
    }
  }
  scheduler();
  musicInterval = setInterval(scheduler, 100);
}

function stopMusic() {
  musicPlaying = false;
  if (musicInterval) { clearInterval(musicInterval); musicInterval = null; }
  if (musicGain) {
    const g = musicGain;
    musicGain = null;
    try {
      g.gain.exponentialRampToValueAtTime(0.001, getAudioCtx().currentTime + 0.3);
      setTimeout(() => { try { g.disconnect(); } catch(e) {} }, 400);
    } catch(e) {}
  }
}

// ============================================================
// LAYOUT CALCULATION
// ============================================================
const gameViewport = document.getElementById('game-viewport');

function calcLayout() {
  const rect = gameViewport.getBoundingClientRect();
  dungeonW = rect.width;
  dungeonH = rect.height;
  groundY = dungeonH * 0.75;
  ceilingY = dungeonH * 0.15;
  playerX = dungeonW * 0.45;
  boulderX = dungeonW * 0.02;
  // Read computed sizes once at layout time, not per-frame
  playerSize = parseFloat(getComputedStyle(playerEl).fontSize) || 48;
  boulderSize = parseFloat(getComputedStyle(boulderEl).fontSize) || 72;
  entitySize = playerSize * 0.8;
}

// ============================================================
// INPUT HANDLING
// ============================================================
// Prevent context menu on right-click (used for duck)
document.addEventListener('contextmenu', e => e.preventDefault());

document.addEventListener('keydown', e => {
  if (!gameRunning) return;
  keysDown[e.code] = true;
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    if (!jumpPressed) { jumpPressed = true; inputJump = true; }
  }
  if (e.code === 'ControlLeft' || e.code === 'ControlRight' || e.code === 'ArrowDown') {
    e.preventDefault();
    if (!duckPressed) { duckPressed = true; inputDuck = true; }
  }
  if (e.code === 'KeyV') {
    e.preventDefault();
    // Spin jump = Jump + Duck simultaneously
    if (!jumpPressed) { jumpPressed = true; inputJump = true; }
    if (!duckPressed) { duckPressed = true; inputDuck = true; }
  }
  if (e.code === 'KeyD') {
    e.preventDefault();
    if (!destroyPressed) { destroyPressed = true; inputDestroy = true; }
  }
});

document.addEventListener('keyup', e => {
  keysDown[e.code] = false;
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    // Only clear jump if no other jump key is held
    if (!keysDown['Space'] && !keysDown['ArrowUp'] && !keysDown['KeyV']) jumpPressed = false;
  }
  if (e.code === 'ControlLeft' || e.code === 'ControlRight' || e.code === 'ArrowDown') {
    if (!keysDown['ControlLeft'] && !keysDown['ControlRight'] && !keysDown['ArrowDown'] && !keysDown['KeyV']) {
      duckPressed = false; inputDuck = false;
    }
  }
  if (e.code === 'KeyV') {
    // Only clear flags if no other key for that action is held
    if (!keysDown['Space'] && !keysDown['ArrowUp']) jumpPressed = false;
    if (!keysDown['ControlLeft'] && !keysDown['ControlRight'] && !keysDown['ArrowDown']) {
      duckPressed = false; inputDuck = false;
    }
  }
  if (e.code === 'KeyD') { destroyPressed = false; }
});

// Mouse: left-click = jump, right-click = duck
document.addEventListener('mousedown', e => {
  if (!gameRunning) return;
  if (e.target.closest('#hud') || e.target.closest('#controls') || e.target.closest('#game-over')) return;
  if (e.button === 0) { // left
    if (!jumpPressed) { jumpPressed = true; inputJump = true; }
  } else if (e.button === 2) { // right
    if (!duckPressed) { duckPressed = true; inputDuck = true; }
  }
});
document.addEventListener('mouseup', e => {
  if (e.button === 0) { jumpPressed = false; }
  if (e.button === 2) { duckPressed = false; inputDuck = false; }
});

// Controls (touch + click for all devices)
const btnJump = document.getElementById('btn-jump');
const btnDuck = document.getElementById('btn-duck');
const btnDestroy = document.getElementById('btn-destroy');

function setupBtn(btn, onDown, onUp) {
  // Touch events
  btn.addEventListener('touchstart', e => { e.preventDefault(); onDown(); });
  btn.addEventListener('touchend', e => { e.preventDefault(); onUp(); });
  btn.addEventListener('touchcancel', e => { e.preventDefault(); onUp(); });
  // Mouse events (for desktop clicking the buttons)
  btn.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); onDown(); });
  btn.addEventListener('mouseup', e => { e.preventDefault(); onUp(); });
  btn.addEventListener('mouseleave', e => { onUp(); });
}

setupBtn(btnJump,
  () => { jumpPressed = true; inputJump = true; btnJump.classList.add('pressed'); },
  () => { jumpPressed = false; btnJump.classList.remove('pressed'); }
);
setupBtn(btnDuck,
  () => { duckPressed = true; inputDuck = true; btnDuck.classList.add('pressed'); },
  () => { duckPressed = false; inputDuck = false; btnDuck.classList.remove('pressed'); }
);
setupBtn(btnDestroy,
  () => { destroyPressed = true; inputDestroy = true; btnDestroy.classList.add('pressed'); },
  () => { destroyPressed = false; btnDestroy.classList.remove('pressed'); }
);

// Prevent scrolling during game
document.addEventListener('touchmove', e => {
  if (gameRunning) e.preventDefault();
}, { passive: false });

// ============================================================
// WALL TORCHES (parallax decoration)
// ============================================================
function createWallTorches() {
  // Remove old torches
  document.querySelectorAll('.wall-torch').forEach(t => t.remove());
  wallTorches = [];
  const spacing = 200;
  const count = Math.ceil(dungeonW / spacing) + 2;
  const yPos = (ceilingY + 10) | 0;
  for (let i = 0; i < count; i++) {
    const el = document.createElement('div');
    el.className = 'wall-torch';
    el.textContent = 'üî•';
    el.style.transform = 'translate3d(' + (i * spacing) + 'px,' + yPos + 'px,0)';
    dungeon.appendChild(el);
    wallTorches.push({ el, baseX: i * spacing, yPos });
  }
}

function updateWallTorches(dt) {
  torchOffsetX = (torchOffsetX + currentSpeed * dt * 30) % 200;
  for (const torch of wallTorches) {
    torch.el.style.transform = 'translate3d(' + ((torch.baseX - torchOffsetX) | 0) + 'px,' + torch.yPos + 'px,0)';
  }
  // Update torch lighting overlay position via background-position
  const px = playerX;
  const py = groundY - playerY - playerSize * 0.5;
  torchOverlay.style.background = 'radial-gradient(ellipse 350px 300px at ' +
    (px | 0) + 'px ' + (py | 0) + 'px, transparent 0%, rgba(0,0,0,0.15) 30%, rgba(0,0,0,0.6) 60%, rgba(0,0,0,0.85) 100%)';
}

// ============================================================
// BATS (decorative, no gameplay interaction)
// ============================================================
let bats = [];
let batTimer = 0;
const BAT_INTERVAL = 1.8; // seconds between bat spawns

function spawnBat() {
  const el = document.createElement('div');
  el.className = 'bat';
  const inner = document.createElement('span');
  inner.className = 'bat-inner';
  inner.textContent = 'ü¶á';
  el.appendChild(inner);
  dungeon.appendChild(el);

  // Random Y in the upper portion of the dungeon (between ceiling and mid-height)
  const minY = ceilingY + 10;
  const maxY = groundY * 0.6;
  const y = minY + Math.random() * (maxY - minY);

  // Random direction: mostly right-to-left, sometimes left-to-right
  const goingLeft = Math.random() > 0.3;
  const startX = goingLeft ? dungeonW + 30 : -30;
  const speed = (120 + Math.random() * 100) * (goingLeft ? -1 : 1);

  // Slight vertical wave
  const waveAmp = 15 + Math.random() * 25;
  const waveSpeed = 2 + Math.random() * 3;

  bats.push({ el, x: startX, y, speed, waveAmp, waveSpeed, age: 0 });
}

function updateBats(dt) {
  batTimer += dt;
  if (batTimer >= BAT_INTERVAL) {
    batTimer -= BAT_INTERVAL;
    if (bats.length < 6) spawnBat();
  }

  for (let i = bats.length - 1; i >= 0; i--) {
    const b = bats[i];
    b.age += dt;
    b.x += b.speed * dt;
    const waveY = Math.sin(b.age * b.waveSpeed) * b.waveAmp;
    b.el.style.transform = 'translate3d(' + (b.x | 0) + 'px,' + ((b.y + waveY) | 0) + 'px,0)';

    // Remove when off-screen
    if ((b.speed < 0 && b.x < -40) || (b.speed > 0 && b.x > dungeonW + 40)) {
      b.el.remove();
      bats.splice(i, 1);
    }
  }
}

function clearBats() {
  for (const b of bats) b.el.remove();
  bats = [];
  batTimer = 0;
}

// ============================================================
// SPAWN LOGIC (seeded RNG)
// ============================================================
function spawnObstacle() {
  const typeIdx = Math.floor(rng() * OBSTACLE_TYPES.length);
  const type = OBSTACLE_TYPES[typeIdx];
  const el = document.createElement('div');
  el.className = 'obstacle' + (type.cssClass ? ' ' + type.cssClass : '');
  const inner = document.createElement('span');
  inner.className = 'obs-inner';
  inner.textContent = type.emoji;
  el.appendChild(inner);

  dungeon.appendChild(el);

  // Determine hint text (misdirection in hard/achal)
  let hintText = null;
  const misleadChance = currentDiff.misleadChance || 0;
  if (misleadChance > 0) {
    const isMislead = rng() < misleadChance;
    const correctHint = type.dodge === 'jump' ? 'JUMP!' : 'DUCK!';
    const wrongHint = type.dodge === 'jump' ? 'DUCK!' : 'JUMP!';
    hintText = isMislead ? wrongHint : correctHint;
  }

  let y;
  if (type.position === 'ground') {
    y = groundY - entitySize;
  } else {
    y = groundY - playerSize * 1.6;
  }

  obstacles.push({
    el, type, x: dungeonW + 20, y,
    width: entitySize, height: entitySize,
    scored: false,
    hintText, hintShown: false
  });

  // Combo spawn: sometimes spawn a pickup alongside the obstacle
  const comboChance = currentDiff.comboChance || 0;
  if (comboChance > 0 && rng() < comboChance) {
    spawnComboPickup(type);
  }
}

// Pickup height tiers:
//   ground  = on the floor (walk through for chests, spin jump for hearts)
//   mid     = regular jump height (~playerSize * 1.2 up)
//   high    = spin jump only (~playerSize * 2 up)
// Pickup heights tuned to jump physics:
// Normal jump peak = 84px, spin jump peak = 117px (v¬≤/2g with gravity=1800)
// Player hitbox at normal peak: 93.6 - 132.0 above ground
// Player hitbox at spin peak:  127.0 - 165.4 above ground
// Mid (center ~105): only normal jump reaches it, spin overshoots
// High (center ~150): only spin jump reaches it, normal falls short
function pickupY(tier) {
  if (tier === 'high') return groundY - entitySize - playerSize * 2.73;
  if (tier === 'mid')  return groundY - entitySize - playerSize * 1.79;
  return groundY - entitySize; // ground
}

function pickRandomTier() {
  // Balance: 35% ground, 35% mid, 30% high
  const r = rng();
  if (r < 0.35) return 'ground';
  if (r < 0.70) return 'mid';
  return 'high';
}

function spawnPickup() {
  const r = rng();
  let type, emoji;
  if (r < currentDiff.heartChance) {
    type = 'heart'; emoji = '‚ù§Ô∏è';
  } else if (r < currentDiff.heartChance + currentDiff.chestChance) {
    type = 'chest'; emoji = 'üì¶';
  } else {
    return; // No pickup this cycle
  }

  const tier = pickRandomTier();
  createPickupAt(type, emoji, dungeonW + 20, pickupY(tier), tier);
}

// Combo pickup: spawned alongside an obstacle for tough decisions
function spawnComboPickup(obstacleType) {
  const isChest = rng() < 0.5;
  const type = isChest ? 'chest' : 'heart';
  const emoji = isChest ? 'üì¶' : '‚ù§Ô∏è';

  // Combo pickups are always high ‚Äî the tricky part
  createPickupAt(type, emoji, dungeonW + 60, pickupY('high'), 'high');
}

function createPickupAt(type, emoji, x, y, tier) {
  const el = document.createElement('div');
  el.className = 'pickup';
  const inner = document.createElement('span');
  inner.className = 'pickup-inner';
  inner.textContent = emoji;
  el.appendChild(inner);
  dungeon.appendChild(el);

  // Collision hitbox is smaller than visual (half height) for precise jump separation.
  // Visual is entitySize tall; collision is centered within it.
  const collH = entitySize * 0.5;
  const collYOffset = (entitySize - collH) / 2; // center the hitbox vertically
  pickups.push({
    el, type, x, y, tier,
    width: entitySize, height: collH,
    collYOffset
  });
}

function throwFireball() {
  if (fireballs <= 0) return;
  fireballs--;
  fireballsThrown++;
  playFireball();

  const el = document.createElement('div');
  el.className = 'fireball-projectile';
  el.textContent = '‚òÑÔ∏è';
  dungeon.appendChild(el);

  projectiles.push({
    el, x: playerX - 20,
    y: groundY - playerSize * 0.7, // always fire at boulder height
    speed: -400 // moves left toward boulder
  });
  updateHUD();
}

// ============================================================
// COLLISION DETECTION (AABB)
// ============================================================
function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function getPlayerHitbox() {
  const px = playerX;
  const w = playerSize * 0.5;
  let h = playerSize * 0.8;
  let py = groundY - playerY - playerSize;
  if (playerDucking && !playerJumping) {
    h *= 0.5;
    py = groundY - playerY - h;
  }
  return { x: px - w * 0.3, y: py, w, h };
}

// ============================================================
// HUD UPDATE
// ============================================================
function updateHUD() {
  hudScore.textContent = 'Score: ' + score;
  let hearts = '';
  for (let i = 0; i < playerMaxHearts; i++) {
    hearts += i < playerHearts ? '‚ù§Ô∏è' : 'üñ§';
  }
  hudHearts.textContent = hearts;
  hudFireballs.textContent = 'üî• ' + fireballs;
  const effectiveMax = Math.max(boulderHP, BOULDER_MAX_HP);
  const hpPct = (boulderHP / effectiveMax * 100);
  boulderHPBar.style.width = hpPct + '%';
  boulderHPText.textContent = boulderHP + '/' + effectiveMax;
  if (hpPct <= 30) boulderHPBar.style.background = 'linear-gradient(90deg, #00AA00, #44FF44)';
  else if (hpPct <= 60) boulderHPBar.style.background = 'linear-gradient(90deg, #AAAA00, #FFFF44)';
  else boulderHPBar.style.background = 'linear-gradient(90deg, #8B0000, #FF4444)';
}

// ============================================================
// SCREEN SHAKE
// ============================================================
let shakeTimeout = null;
function shakeScreen() {
  if (shakeTimeout) { clearTimeout(shakeTimeout); }
  gameViewport.classList.remove('shake');
  requestAnimationFrame(() => {
    gameViewport.classList.add('shake');
    shakeTimeout = setTimeout(() => {
      gameViewport.classList.remove('shake');
      shakeTimeout = null;
    }, 300);
  });
}

// ============================================================
// APPLY DUNGEON COLORS
// ============================================================
function applyColors(colors) {
  dungeon.style.background = `linear-gradient(180deg, ${colors.bg1} 0%, ${colors.bg2} 50%, ${colors.bg3} 100%)`;
  const ground = document.getElementById('ground');
  ground.style.background = `linear-gradient(0deg, ${colors.ground1} 0%, ${colors.ground2} 50%, ${colors.ground3} 100%)`;
  ground.style.borderTop = `3px solid ${colors.border}`;
  const ceiling = document.getElementById('ceiling');
  ceiling.style.background = `linear-gradient(180deg, ${colors.ceiling} 0%, ${colors.bg1} 100%)`;
  ceiling.style.borderBottom = `3px solid ${colors.border}`;
}

// ============================================================
// GAME LOOP
// ============================================================
let lastFrameTime = 0;
let animFrameId = null;

function gameLoop(timestamp) {
  if (!gameRunning) return;
  animFrameId = requestAnimationFrame(gameLoop);

  const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.05); // cap delta
  lastFrameTime = timestamp;
  elapsedMs = timestamp - gameStartTime;

  // --- 1. Update speed ---
  if (currentSpeed < currentDiff.maxSpeed) {
    currentSpeed += currentDiff.rampRate * dt * 1000;
    if (currentSpeed > currentDiff.maxSpeed) currentSpeed = currentDiff.maxSpeed;
  }

  // --- 2. Handle jump input ---
  if (inputJump && inputDuck && !playerJumping) {
    // Spin jump
    playerJumping = true;
    playerSpinning = true;
    spinTimer = 0.5;
    playerVelY = 650;
    playerDucking = false;
    playSpin();
    inputJump = false;
    inputDuck = false;
  } else if (inputJump && !playerJumping) {
    playerJumping = true;
    playerVelY = 550;
    playJump();
    inputJump = false;
  } else {
    inputJump = false;
  }

  // Duck state (time-limited)
  if (duckPressed && !playerJumping && duckTimer < DUCK_DURATION) {
    if (!playerDucking) { playDuck(); duckTimer = 0; }
    playerDucking = true;
    duckTimer += dt;
    if (duckTimer >= DUCK_DURATION) {
      playerDucking = false; // auto-stand
    }
  } else {
    playerDucking = false;
    // Reset timer when not ducking and key released
    if (!duckPressed) duckTimer = 0;
  }

  // Throw fireball
  if (inputDestroy) {
    inputDestroy = false;
    throwFireball();
  }

  // --- 3. Player physics ---
  if (playerJumping) {
    playerVelY -= 1800 * dt; // gravity
    playerY += playerVelY * dt;
    if (playerY <= 0) {
      playerY = 0;
      playerVelY = 0;
      playerJumping = false;
    }
  }

  // Spin timer
  if (playerSpinning) {
    spinTimer -= dt;
    if (spinTimer <= 0) playerSpinning = false;
  }

  // Invincibility timer
  if (invincibleTimer > 0) invincibleTimer -= dt;

  // --- 4. Position player (use transform3d for GPU compositing) ---
  const playerDrawY = groundY - playerY - playerSize;
  const isDucking = playerDucking && !playerJumping;
  const duckScale = isDucking ? 'scaleY(0.55)' : '';
  playerEl.style.transform = 'translate3d(' + playerX + 'px,' + playerDrawY + 'px,0) ' + duckScale;
  if (isDucking) playerEl.style.transformOrigin = 'center bottom';

  // Toggle classes only when state changes
  const isInvincible = invincibleTimer > 0;
  if (playerEl._lastSpin !== playerSpinning) {
    playerEl.classList.toggle('spinning', playerSpinning);
    playerEl._lastSpin = playerSpinning;
  }
  if (playerEl._lastInv !== isInvincible) {
    playerEl.classList.toggle('invincible', isInvincible);
    playerEl._lastInv = isInvincible;
  }

  // Player sprite: only update textContent when state changes
  if (isDucking) {
    if (playerEl._lastState !== 'duck') {
      playerSprite.textContent = 'üßé';
      playerEl._lastState = 'duck';
    }
    playerSprite.style.transform = 'scaleX(-1)';
  } else if (playerSpinning) {
    if (playerEl._lastState !== 'spin') {
      playerSprite.textContent = 'üèÉ';
      playerEl._lastState = 'spin';
    }
    playerSprite.style.transform = '';
  } else {
    if (playerEl._lastState !== 'run') {
      playerSprite.textContent = 'üèÉ';
      playerEl._lastState = 'run';
    }
    const bobY = (Math.floor(elapsedMs / 150) & 1) ? -3 : 0;
    playerSprite.style.transform = 'scaleX(-1) translateY(' + bobY + 'px)';
  }

  // --- 5. Position boulder (use transform3d, cached boulderSize) ---
  boulderEl.style.transform = 'translate3d(' + boulderX + 'px,' + (groundY - boulderSize) + 'px,0)';
  // Update roll speed only when speed changes meaningfully
  const rollDur = Math.max(0.15, 0.8 / (currentSpeed / 3));
  const rollDurRounded = (rollDur * 10 | 0) / 10; // round to 0.1s
  if (boulderEl._lastRoll !== rollDurRounded) {
    boulderSprite.style.animationDuration = rollDurRounded + 's';
    boulderEl._lastRoll = rollDurRounded;
  }

  // --- 6. Move obstacles (transform3d for GPU) ---
  const moveAmount = currentSpeed * dt * 80;
  let hudDirty = false;
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];
    obs.x -= moveAmount;
    obs.el.style.transform = 'translate3d(' + (obs.x | 0) + 'px,' + (obs.y | 0) + 'px,0)';

    if (!obs.scored && obs.x + obs.width < playerX - playerSize * 0.15) {
      obs.scored = true;
      score++;
      obstaclesDodged++;
      hudDirty = true;
    }

    // Hard/Achal: fire pits heal the boulder when they reach it
    if (!obs.healed && obs.type.id === 'fire_pit' && currentDiff.misleadChance &&
        obs.x < boulderX + boulderSize && obs.x + obs.width > boulderX) {
      obs.healed = true;
      const canHeal = lastDiffKey === 'achal' || boulderHP < BOULDER_MAX_HP;
      if (canHeal) {
        boulderHP++;
        hudDirty = true;
        showFloatingText(boulderX + boulderSize * 0.5, groundY - boulderSize - 10, '+1', '#FF4444');
      }
    }

    if (obs.x < -100) {
      if (activeHintObs === obs) { activeHintObs = null; centerHint.classList.remove('visible'); }
      obs.el.remove();
      obstacles.splice(i, 1);
    }
  }

  // --- Center hint: show hint when obstacle is approaching player ---
  {
    // Trigger distance: enough ahead of player to read (scales with speed)
    const hintDist = playerSize * 3 + currentSpeed * 25;
    let showingHint = false;
    for (const obs of obstacles) {
      if (obs.scored || !obs.hintText) continue;
      const dist = obs.x - playerX;
      // Show hint when obstacle enters the trigger zone
      if (dist > 0 && dist < hintDist && !obs.hintShown) {
        obs.hintShown = true;
        activeHintObs = obs;
        centerHint.textContent = obs.hintText;
        centerHint.classList.add('visible');
        showingHint = true;
        break;
      }
      // Keep showing while obstacle is still ahead
      if (activeHintObs === obs && dist > -entitySize) {
        showingHint = true;
      }
    }
    // Hide hint once the obstacle passes the player
    if (!showingHint && activeHintObs) {
      activeHintObs = null;
      centerHint.classList.remove('visible');
    }
  }

  // --- 7. Move pickups ---
  for (let i = pickups.length - 1; i >= 0; i--) {
    const p = pickups[i];
    p.x -= moveAmount;
    p.el.style.transform = 'translate3d(' + (p.x | 0) + 'px,' + (p.y | 0) + 'px,0)';

    if (p.x < -100) {
      p.el.remove();
      pickups.splice(i, 1);
    }
  }

  // --- 8. Move projectiles ---
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    proj.x += proj.speed * dt;
    proj.el.style.transform = 'translate3d(' + (proj.x | 0) + 'px,' + (proj.y | 0) + 'px,0)';

    // Check if hit boulder
    const bx = boulderX;
    const by = groundY - boulderSize;
    if (rectsOverlap(proj.x, proj.y, 32, 32, bx, by, boulderSize, boulderSize)) {
      proj.el.remove();
      projectiles.splice(i, 1);
      boulderHP--;
      playBoulderHit();
      shakeScreen();
      hudDirty = true;
      if (boulderHP <= 0) {
        winGame();
        return;
      }
      continue;
    }

    // Remove if off-screen
    if (proj.x < -50) {
      proj.el.remove();
      projectiles.splice(i, 1);
    }
  }

  // --- 9. Collision: obstacles vs player ---
  if (invincibleTimer <= 0) {
    const ph = getPlayerHitbox();
    for (const obs of obstacles) {
      if (obs.scored) continue;
      // Horizontal overlap check (shared by all obstacle types)
      const hOverlap = ph.x < obs.x + obs.width && ph.x + ph.w > obs.x;
      if (!hOverlap) continue;

      let hit = false;
      if (obs.type.dodge === 'jump') {
        // Ground obstacle: must jump high enough to clear
        const vOverlap = rectsOverlap(ph.x, ph.y, ph.w, ph.h, obs.x, obs.y, obs.width, obs.height);
        if (vOverlap) {
          const dodged = playerJumping && playerY > playerSize * 0.35;
          if (!dodged) hit = true;
        }
      } else if (obs.type.dodge === 'duck') {
        // Head-height obstacle: ONLY ducking avoids it. Jumping does NOT help.
        const dodged = playerDucking && !playerJumping;
        if (!dodged) hit = true;
      }

      if (hit) {
        playerHearts--;
        invincibleTimer = 1.5;
        playHit();
        shakeScreen();
        hudDirty = true;
        if (playerHearts <= 0) {
          loseGame();
          return;
        }
      }
    }
  }

  // --- 10. Collision: pickups vs player ---
  {
    const ph = getPlayerHitbox();
    for (let i = pickups.length - 1; i >= 0; i--) {
      const p = pickups[i];
      const py = p.y + (p.collYOffset || 0);
      if (rectsOverlap(ph.x, ph.y, ph.w, ph.h, p.x, py, p.width, p.height)) {
        // Physics handles reachability: collision hitbox is small so
        // normal jump only reaches mid, spin jump only reaches high.
        if (p.type === 'chest') {
          fireballs++;
          playChestOpen();
          showFloatingText(p.x, p.y, '+üî•', '#FF8800');
          p.el.remove();
          pickups.splice(i, 1);
          hudDirty = true;
        } else if (p.type === 'heart') {
          if (playerHearts < playerMaxHearts) {
            playerHearts++;
            playHeartCollect();
            showFloatingText(p.x, p.y, '+‚ù§Ô∏è', '#FF4444');
            hudDirty = true;
          } else {
            score += 5;
            playHeartCollect();
            showFloatingText(p.x, p.y, '+5', '#FFD700');
            hudDirty = true;
          }
          p.el.remove();
          pickups.splice(i, 1);
        }
      }
    }
  }

  // --- 11. Spawning ---
  spawnTimer += dt;
  if (spawnTimer >= nextSpawnTime) {
    spawnTimer = 0;
    nextSpawnTime = currentDiff.spawnInterval + (rng() - 0.5) * 2 * currentDiff.spawnVariance;
    if (nextSpawnTime < 0.5) nextSpawnTime = 0.5;
    spawnObstacle();
  }

  pickupTimer += dt;
  if (pickupTimer >= nextPickupTime) {
    pickupTimer = 0;
    nextPickupTime = currentDiff.spawnInterval * 1.5 + 1 + (rng() - 0.5);
    if (nextPickupTime < 1) nextPickupTime = 1;
    spawnPickup();
  }

  // --- 12. Batch HUD update (once per frame, not per-event) ---
  if (hudDirty) updateHUD();

  // --- 13. Wall torches ---
  updateWallTorches(dt);

  // --- 14. Bats ---
  updateBats(dt);
}

// ============================================================
// FLOATING TEXT
// ============================================================
function showFloatingText(x, y, text, color) {
  const el = document.createElement('div');
  el.className = 'floating-text';
  el.style.cssText = `position:absolute;left:${x}px;top:${y}px;font-size:1.5rem;font-weight:bold;
    color:${color};z-index:50;pointer-events:none;text-shadow:1px 1px 2px rgba(0,0,0,0.5);`;
  dungeon.appendChild(el);
  el.textContent = text;
  el.animate([
    { transform: 'translateY(0)', opacity: 1 },
    { transform: 'translateY(-50px)', opacity: 0 }
  ], { duration: 800, easing: 'ease-out' });
  setTimeout(() => el.remove(), 800);
}

// ============================================================
// INTRO SEQUENCE (plays inside the actual dungeon)
// ============================================================
function playIntro(callback) {
  // Show game screen with dungeon rendered, but hide HUD
  gameScreen.classList.add('active');
  gameOverScreen.classList.remove('active');
  const hud = document.getElementById('hud');
  hud.style.display = 'none';
  controlsEl.classList.remove('active');

  calcLayout();
  applyColors(currentDiff.colors);
  createWallTorches();

  // Set torch lighting overlay centered on player position
  const px = playerX | 0;
  const py = (groundY - playerSize * 0.5) | 0;
  torchOverlay.style.background = 'radial-gradient(ellipse 350px 300px at ' +
    px + 'px ' + py + 'px, transparent 0%, rgba(0,0,0,0.15) 30%, rgba(0,0,0,0.6) 60%, rgba(0,0,0,0.85) 100%)';

  // Position player standing in center, facing right
  playerSprite.textContent = 'üßç';
  playerSprite.style.transform = 'scaleX(-1)';
  playerEl.style.transform = 'translate3d(' + playerX + 'px,' + (groundY - playerSize) + 'px,0)';
  playerEl.classList.remove('spinning', 'invincible');
  playerEl._lastState = null;

  // Boulder starts off-screen above its landing spot
  boulderEl.style.transform = 'translate3d(' + boulderX + 'px,' + (-boulderSize * 2) + 'px,0)';
  boulderSprite.style.animationPlayState = 'paused';

  // Reset intro elements
  introScaredEl.classList.remove('visible');
  introTextEl.classList.remove('visible');

  // 0.6s: Boulder drops into its gameplay position
  setTimeout(() => {
    boulderEl.style.transition = 'transform 0.5s cubic-bezier(0.6, 0, 1, 1)';
    boulderEl.style.transform = 'translate3d(' + boulderX + 'px,' + (groundY - boulderSize) + 'px,0)';
    playBoulderDrop();
  }, 600);

  // 1.1s: Screen shake on impact
  setTimeout(() => {
    boulderEl.style.transition = '';
    shakeScreen();
  }, 1100);

  // 1.2s: Player turns left to look at boulder, scared emoji above
  setTimeout(() => {
    playerSprite.style.transform = 'scaleX(1)'; // face left
    // Position scared emoji above player
    introScaredEl.style.left = (playerX + 10) + 'px';
    introScaredEl.style.top = (groundY - playerSize - 45) + 'px';
    introScaredEl.classList.add('visible');
  }, 1200);

  // 1.6s: Boulder starts rolling, "RUN!!!" appears
  setTimeout(() => {
    boulderSprite.style.animationPlayState = 'running';
    introTextEl.classList.add('visible');
  }, 1600);

  // 2.1s: Player turns right and becomes runner, scared disappears
  setTimeout(() => {
    introScaredEl.classList.remove('visible');
    playerSprite.textContent = 'üèÉ';
    playerSprite.style.transform = 'scaleX(-1)';
  }, 2100);

  // 2.8s: Transition to gameplay
  setTimeout(() => {
    introTextEl.classList.remove('visible');
    hud.style.display = '';
    callback();
  }, 2800);
}

// ============================================================
// START / STOP / WIN / LOSE
// ============================================================
function beginGame(diffKey) {
  lastDiffKey = diffKey;
  currentDiff = DIFFICULTY[diffKey];

  // Seed RNG
  rng = mulberry32(dateSeed(getTodayStr(), diffKey));

  titleScreen.classList.add('hidden');
  playIntro(() => {
    startGameplay();
  });
}

function startGameplay() {
  gameRunning = true;
  score = 0;
  obstaclesDodged = 0;
  fireballsThrown = 0;
  playerHearts = playerMaxHearts;
  playerY = 0;
  playerVelY = 0;
  playerJumping = false;
  playerDucking = false;
  duckTimer = 0;
  playerSpinning = false;
  spinTimer = 0;
  invincibleTimer = 0;
  fireballs = 0;
  boulderHP = BOULDER_MAX_HP;
  currentSpeed = currentDiff.startSpeed;
  obstacles = [];
  pickups = [];
  projectiles = [];
  spawnTimer = 0;
  pickupTimer = 0;
  nextSpawnTime = currentDiff.spawnInterval;
  nextPickupTime = currentDiff.spawnInterval * 1.5 + 1;
  torchOffsetX = 0;

  // Clear old entities from DOM
  dungeon.querySelectorAll('.obstacle, .pickup, .fireball-projectile').forEach(e => e.remove());

  // Show game screen BEFORE calcLayout so viewport has dimensions
  gameScreen.classList.add('active');
  gameOverScreen.classList.remove('active');

  calcLayout();
  applyColors(currentDiff.colors);
  createWallTorches();
  updateHUD();

  // Always show controls (works for touch, mouse clicks, and as visual reference)
  controlsEl.classList.add('active');

  boulderSprite.style.animationPlayState = 'running';
  startMusic();
  gameStartTime = performance.now();
  lastFrameTime = performance.now();
  animFrameId = requestAnimationFrame(gameLoop);
}

function stopGame() {
  gameRunning = false;
  if (animFrameId) { cancelAnimationFrame(animFrameId); animFrameId = null; }
  stopMusic();
  // Clean up entity DOM elements
  dungeon.querySelectorAll('.obstacle, .pickup, .fireball-projectile, .floating-text').forEach(e => e.remove());
  obstacles = [];
  pickups = [];
  projectiles = [];
  clearBats();
  activeHintObs = null;
  centerHint.classList.remove('visible');
  boulderSprite.style.animationPlayState = 'paused';
}

function winGame() {
  stopGame();
  setTimeout(() => {
    playVictory();
    showGameOver(true);
  }, 300);
}

function loseGame() {
  stopGame();
  setTimeout(() => {
    playGameOver();
    showGameOver(false);
  }, 300);
}

function showGameOver(victory) {
  const title = document.getElementById('go-title');
  if (victory) {
    title.textContent = 'Boulder Destroyed!';
    title.className = 'victory';
  } else {
    title.textContent = 'You Perished!';
    title.className = 'defeat';
  }
  const timeSec = (elapsedMs / 1000).toFixed(1);
  document.getElementById('go-score').textContent = 'Score: ' + score;
  document.getElementById('go-difficulty').textContent = currentDiff.label + ' Mode';
  document.getElementById('go-time').textContent = 'Time: ' + timeSec + 's';
  document.getElementById('go-obstacles').textContent = 'Obstacles dodged: ' + obstaclesDodged;
  document.getElementById('go-fireballs').textContent = 'Fireballs thrown: ' + fireballsThrown;
  gameOverScreen.classList.add('active');
}

function restartGame() {
  gameOverScreen.classList.remove('active');
  gameScreen.classList.remove('active');
  // Re-seed for fresh daily run
  rng = mulberry32(dateSeed(getTodayStr(), lastDiffKey));
  startGameplay();
}

function quitGame() {
  stopGame();
  gameScreen.classList.remove('active');
  gameOverScreen.classList.remove('active');
  controlsEl.classList.remove('active');
  titleScreen.classList.remove('hidden');
}

// Handle resize
window.addEventListener('resize', () => {
  if (gameRunning) {
    calcLayout();
    createWallTorches();
  }
});

// Pause timing when tab hidden to prevent elapsed time jumps
document.addEventListener('visibilitychange', () => {
  if (document.hidden && gameRunning) {
    // Store the pause point; on resume lastFrameTime resets via rAF
    lastFrameTime = performance.now();
  }
});
</script>
</body>
</html>
